<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BGLib.Core</name>
    </assembly>
    <members>
        <member name="P:BGLib.Core.AttributeClient.AttributeValueEventArgs.Connection">
            <summary>
            Connection handle
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeClient.AttributeValueEventArgs.AttHandle">
            <summary>
            Attribute handle
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeClient.AttributeValueEventArgs.Type">
            <summary>
            Attribute type
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeClient.AttributeValueEventArgs.Value">
            <summary>
            Attribute value (data)
            </summary>
        </member>
        <member name="T:BGLib.Core.AttributeClient.AttributeValueType">
            <summary>
            These enumerations are in the Attribute Client class
            </summary>
        </member>
        <member name="F:BGLib.Core.AttributeClient.AttributeValueType.Read">
            <summary>
            Value was read
            </summary>
        </member>
        <member name="F:BGLib.Core.AttributeClient.AttributeValueType.Notify">
            <summary>
            Value was notified
            </summary>
        </member>
        <member name="F:BGLib.Core.AttributeClient.AttributeValueType.Indicate">
            <summary>
            Value was indicated
            </summary>
        </member>
        <member name="F:BGLib.Core.AttributeClient.AttributeValueType.ReadByType">
            <summary>
            Value was read
            </summary>
        </member>
        <member name="F:BGLib.Core.AttributeClient.AttributeValueType.ReadBlob">
            <summary>
            Value was part of a long attribute
            </summary>
        </member>
        <member name="F:BGLib.Core.AttributeClient.AttributeValueType.IndicateRspReq">
            <summary>
            <para>
            Value was indicated and the remote device is
            waiting for a confirmation.
            </para>
            <para>
            Indicate Confirm command can be used to send a
            confirmation.
            </para>
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeClient.FindInformationFoundEventArgs.Connection">
            <summary>
            Connection handle
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeClient.FindInformationFoundEventArgs.ChrHandle">
            <summary>
            Characteristics handle
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeClient.FindInformationFoundEventArgs.UUID">
            <summary>
            Characteristics type (UUID)
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeClient.GroupFoundEventArgs.Connection">
            <summary>
            Connection handle
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeClient.GroupFoundEventArgs.Start">
            <summary>
            Starting handle
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeClient.GroupFoundEventArgs.End">
            <summary>
            Ending handle
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeClient.GroupFoundEventArgs.UUID">
            <summary>
            <para>UUID of a service</para>
            <para>Length is 0 if no services are found.</para>
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeClient.IndicatedEventArgs.Connection">
            <summary>
            Connection handle
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeClient.IndicatedEventArgs.AttrHandle">
            <summary>
            Attribute handle
            </summary>
        </member>
        <member name="T:BGLib.Core.AttributeClient.Messenger">
            <summary>
            The Attribute Client class implements the Bluetooth Low Energy Attribute Protocol (ATT) and provides access
            to the ATT protocol methods. The Attribute Client class can be used to discover services and characteristics
            from the ATT server, read and write values and manage indications and notifications.
            </summary>
        </member>
        <member name="M:BGLib.Core.AttributeClient.Messenger.FindByTypeValueAsync(System.Byte,System.UInt16,System.UInt16,System.UInt16,System.Byte[])">
            <summary>
            <para>
            This command can be used to find specific attributes on a remote device based on their 16-bit UUID value and
            value.The search can be limited by a starting and ending handle values.
            </para>
            <para>
            The command returns the handles of all attributes matching the type (UUID) and value.
            </para>
            </summary>
            <param name="connection">Connection handle</param>
            <param name="start">First requested handle number</param>
            <param name="end">Last requested handle number</param>
            <param name="uuid">2 octet UUID to find</param>
            <param name="value">Attribute value to find</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.AttributeClient.Messenger.ReadByGroupTypeAsync(System.Byte,System.UInt16,System.UInt16,System.Byte[])">
            <summary>
            <para>
            This command reads the value of each attribute of a given type and in a given handle range.
            </para>
            <para>
            The command is typically used for primary (UUID: 0x2800) and secondary (UUID: 0x2801) service discovery.
            </para>
            <para>
            Discovered services are reported by Group Found event.
            </para>
            <para>
            Finally when the procedure is completed a Procedure Completed event is generated.
            </para>
            </summary>
            <param name="connection">Connection Handle</param>
            <param name="start">First requested handle number</param>
            <param name="end">Last requested handle number</param>
            <param name="uuid">Group UUID to find</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.AttributeClient.Messenger.ReadByTypeAsync(System.Byte,System.UInt16,System.UInt16,System.Byte[])">
            <summary>
            <para>
            The command reads the value of each attribute of a given type (UUID) and in a given attribute handle range.
            </para>
            <para>
            The command can for example be used to discover the characteristic declarations (UUID: 0x2803) within a
            service.
            </para>
            </summary>
            <param name="connection">Connection handle</param>
            <param name="start">First attribute handle</param>
            <param name="end">Last attribute handle</param>
            <param name="uuid">Attribute type (UUID)</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.AttributeClient.Messenger.FindInformationAsync(System.Byte,System.UInt16,System.UInt16)">
            <summary>
            This command is used to discover attribute handles and their types (UUIDs) in a given handle range.
            </summary>
            <param name="connection">Connection handle</param>
            <param name="start">First attribute handle</param>
            <param name="end">Last attribute handle</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.AttributeClient.Messenger.ReadByHandleAsync(System.Byte,System.UInt16)">
            <summary>
            <para>
            This command reads a remote attribute's value with the given handle. Read by handle can be used to read
            attributes up to 22 bytes long.
            </para>
            <para>
            For longer attributes Read Long command must be used.
            </para>
            </summary>
            <param name="connection">Connection Handle</param>
            <param name="chrHandle">Attribute handle</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.AttributeClient.Messenger.AttributeWriteAsync(System.Byte,System.UInt16,System.Byte[])">
            <summary>
            <para>
            This command can be used to write an attributes value on a remote device. In order to write the value of an
            attribute a Bluetooth connection must exists and you need to know the handle of the attribute you want to write.
            </para>
            <para>
            A successful attribute write will be acknowledged by the remote device and this will generate an event
            attclient_procedure_completed.The acknowledgement should happen within a 30 second window or otherwise
            the Bluetooth connection will be dropped.
            </para>
            <para>
            This command should be used for writing data to characteristic with property write="true".
            </para>
            <para>
            The data payload for the Attribute Write command can be up to 20 bytes.
            </para>
            </summary>
            <param name="connection">Connection handle</param>
            <param name="attHandle">Attribute handle to write to</param>
            <param name="data">Attribute value</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.AttributeClient.Messenger.WriteCommandAsync(System.Byte,System.UInt16,System.Byte[])">
            <summary>
            <para>
            Writes the value of a remote devices attribute. The handle and the new value of the attribute are gives as
            parameters.
            </para>
            <para>
            Write command will not be acknowledged by the remote device unlike Attribute Write. This command
            should be used for writing data to characteristic with property write_no_response="true".
            </para>
            <para>
            The maximum data payload for Write Command is 20 bytes.
            </para>
            </summary>
            <param name="connection">Connection handle</param>
            <param name="attHandle">Attribute handle to write</param>
            <param name="data">Value for the attribute</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.AttributeClient.Messenger.IndicateConfirmAsync(System.Byte)">
            <summary>
            <para>
            This command can be used to send a acknowledge a received indication from a remote device. This function
            allows the application to manually confirm the indicated values instead of the Bluetooth Low Energy stack
            automatically doing it.The benefit of this is extra reliability since the application can for example store the
            received value on the flash memory before confirming the indication to the remote device.
            </para>
            <para>
            In order to use this feature the manual indication acknowledgements must be enabled to the
            application configuration file(config.xml).
            </para>
            </summary>
            <param name="connection">Connection Handle</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.AttributeClient.Messenger.ReadLongAsync(System.Byte,System.UInt16)">
            <summary>
            <para>
            This command can be used to read long attribute values, which are longer than 22 bytes and cannot be read
            with a simple Read by Handle command.
            </para>
            The command starts a procedure, where the client first sends a normal read command to the server and if the
            returned attribute value length is equal to MTU, the client will send further read long read requests until rest of
            the attribute is read.
            <para>
            </para>
            </summary>
            <param name="connection">Connection Handle</param>
            <param name="chrHandle">Attribute handle</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.AttributeClient.Messenger.PrepareWriteAsync(System.Byte,System.UInt16,System.UInt16,System.Byte[])">
            <summary>
            <para>
            This command will send a prepare write request to a remote device for queued writes. Queued writes can for
            example be used to write large attribute values by transmitting the data in chunks using prepare write
            command.
            </para>
            <para>
            Once the data has been transmitted with multiple prepare write commands the write must then be executed or
            canceled with Execute Write command, which if acknowledged by the remote device triggers a Procedure
            Completed event.
            </para>
            <para>
            The example below shows how this approach can be used to write a 30-byte characteristic value:
            </para>
            <para>1. attclient_prepare_write(...., partial data)</para>
            <para>2. wait for rsp_attclient_prepare_write</para>
            <para>3. wait for evt_attclient_procedure_completed</para>
            <para>4. attclient_prepare_write(...., partial data)</para>
            <para>5. wait for rsp_attclient_prepare_write</para>
            <para>6. wait for evt_attclient_procedure_completed</para>
            <para>7. attclient_execute_write(1)</para>
            <para>8. wait for rsp_attclient_prepare_write</para>
            <para>9. wait for evt_attclient_procedure_completed</para>
            <para>
            It is not mandatory for an ATT server to support this command. It is only recommended to use this
            command to write long-attributes which do not fit in single ATT packet.
            </para>
            </summary>
            <param name="connection">Connection Handle</param>
            <param name="attHandle">Attribute handle</param>
            <param name="offset">Offset to write to</param>
            <param name="data">
            <para>
            Data to write
            </para>
            <para>
            Maximum amount of data that can be sent in single command is 18 bytes.
            </para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.AttributeClient.Messenger.ExecuteWriteAsync(System.Byte,System.Byte)">
            <summary>
            This command can be used to execute or cancel a previously queued prepare_write command on a remote
            device.
            </summary>
            <param name="connection">Connection Handle</param>
            <param name="commit">
            <para>0: cancels queued writes</para>
            <para>1: commits queued writes</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.AttributeClient.Messenger.ReadMultipleAsync(System.Byte,System.Byte[])">
            <summary>
            This command can be used to read multiple attributes from a server.
            </summary>
            <param name="connection">Connection handle</param>
            <param name="handles">List of attribute handles to read from the remote device</param>
            <returns></returns>
        </member>
        <member name="E:BGLib.Core.AttributeClient.Messenger.Indicated">
            <summary>
            <para>
            This event is produced at the GATT server side when an attribute is successfully indicated to the GATT client.
            </para>
            <para>
            This means the event is only produced at the GATT server if the indication is acknowledged by the GATT client
            (the remote device).
            </para>
            </summary>
        </member>
        <member name="E:BGLib.Core.AttributeClient.Messenger.ProcedureCompleted">
            <summary>
            <para>
            This event is produced at the GATT client when an attribute protocol event is completed a and new operation
            can be issued.
            </para>
            <para>
            This event is for example produced after an Attribute Write command is successfully used to write a value to a
            remote device.
            </para>
            </summary>
        </member>
        <member name="E:BGLib.Core.AttributeClient.Messenger.GroupFound">
            <summary>
            This event is produced when an attribute group (a service) is found. Typically this event is produced after Read
            by Group Type command.
            </summary>
        </member>
        <member name="E:BGLib.Core.AttributeClient.Messenger.FindInformationFound">
            <summary>
            This event is generated when characteristics type mappings are found. This happens yypically after Find
            Information command has been issued to discover all attributes of a service.
            </summary>
        </member>
        <member name="E:BGLib.Core.AttributeClient.Messenger.AttributeValue">
            <summary>
            This event is produced at the GATT client side when an attribute value is passed from the GATT server to the
            GATT client.This event is for example produced after a successful Read by Handle operation or when an
            attribute is indicated or notified by the remote device.
            </summary>
        </member>
        <member name="E:BGLib.Core.AttributeClient.Messenger.ReadMultipleResopnse">
            <summary>
            This event is a response to a Read Multiple request.
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeClient.ProcedureCompletedEventArgs.Connection">
            <summary>
            Object Handle
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeClient.ProcedureCompletedEventArgs.ChrHandle">
            <summary>
            Characteristic handle at which the event ended
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeClient.ReadMultipleResponseEventArgs.Connection">
            <summary>
            Connection handle
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeClient.ReadMultipleResponseEventArgs.Handles">
            <summary>
            This array contains the concatenated data from the multiple attributes that
            have been read, up to 22 bytes.
            </summary>
        </member>
        <member name="T:BGLib.Core.AttributeDatabase.AttributeChangeReason">
            <summary>
            This enumeration contains the reason for an attribute value change.
            </summary>
        </member>
        <member name="F:BGLib.Core.AttributeDatabase.AttributeChangeReason.WriteRequest">
            <summary>
            Value was written by remote device using write request
            </summary>
        </member>
        <member name="F:BGLib.Core.AttributeDatabase.AttributeChangeReason.WriteCommand">
            <summary>
            Value was written by remote device using write command
            </summary>
        </member>
        <member name="F:BGLib.Core.AttributeDatabase.AttributeChangeReason.WriteRequestUser">
            <summary>
            <para>
            Local attribute value was written by the remote device, but the
            Bluetooth Low Energy stack is waiting for the write to be confirmed
            by the application.
            </para>
            <para>
            User Write Response command should be used to send the confirmation.
            </para>
            <para>
            For this reason to appear the attribute in the GATT database must have
            the user property enabled.
            </para>
            <para>
            See Profile Toolkit Developer Guide for more information how to enable
            the user property for an attribute.
            </para>
            </summary>
        </member>
        <member name="T:BGLib.Core.AttributeDatabase.AttributeStatus">
            <summary>
            Attribute status flags
            </summary>
        </member>
        <member name="F:BGLib.Core.AttributeDatabase.AttributeStatus.Notify">
            <summary>
            Notifications are enabled
            </summary>
        </member>
        <member name="F:BGLib.Core.AttributeDatabase.AttributeStatus.Indicate">
            <summary>
             Indications are enabled
            </summary>
        </member>
        <member name="T:BGLib.Core.AttributeDatabase.Messenger">
            <summary>
            The Attribute Database class provides methods to read and write attributes to the local devices Attribute
            Database. This class is usually only needed on sensor devices(Attribute server) for example to update
            attribute values to the local database based on the sensor readings.A remote device then can access the
            GATT database and these values over a Bluetooth connection.
            </summary>
        </member>
        <member name="M:BGLib.Core.AttributeDatabase.Messenger.WriteAttributeAsync(System.UInt16,System.Byte,System.Byte[])">
            <summary>
            This command writes an attribute's value to the local database.
            </summary>
            <param name="handle">Handle of the attribute to write</param>
            <param name="offset">Attribute offset to write data</param>
            <param name="value">Value of the attribute to write</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.AttributeDatabase.Messenger.ReadAsync(System.UInt16,System.UInt16)">
            <summary>
            <para>
            The command reads the given attribute's value from the local database. There is a 32-byte limit in the amount
            of data that can be read at a time.In order to read larger values multiple read commands must be used with the
            offset properly used.
            </para>
            <para>For example to read a 64 bytes attribute:</para>
            <para>1. Read first 32 bytes using offset 0</para>
            <para>2. Read second 32 bytes using offset 32</para>
            </summary>
            <param name="handle">Handle of the attribute to read</param>
            <param name="offset">
            <para>Offset to read from.</para>
            <para>Maximum of 32 bytes can be read at a time.</para>
            </param>
            <returns>Value of the attribute</returns>
        </member>
        <member name="M:BGLib.Core.AttributeDatabase.Messenger.ReadTypeAsync(System.UInt16)">
            <summary>
            This command reads the given attribute's type (UUID) from the local database.
            </summary>
            <param name="handle">Handle of the attribute to read</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.AttributeDatabase.Messenger.UserReadResponseAsync(System.Byte,System.Byte,System.Byte[])">
            <summary>
            <para>
            This command is used to respond to an attribute Read request by a remote device, but only for attributes which
            have been configured with the user property.Attributes which have the user property enabled allow the attribute
            value to be requested from the application instead of the Bluetooth Low Energy stack automatically responding
            with the data in it's local GATT database.
            </para>
            <para>
            This command is normally used in response to a User Read Request event, which is generated when a remote
            device tries to read an attribute with a user property enabled.
            </para>
            <para>
            The response to User Read Request events must happen within 30 seconds or otherwise a timeout will occur.
            </para>
            </summary>
            <param name="connection">Connection handle to respond to</param>
            <param name="attError">
            <para>0: User Read Request is responded with data.</para>
            <para>In case of an error an application specific error code can be sent.</para>
            </param>
            <param name="value">Data to send</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.AttributeDatabase.Messenger.UserWriteResponseAsync(System.Byte,System.Byte)">
            <summary>
            <para>
            This command is used by the GATT server to acknowledge to the remote device that the attribute's value was
            written.This feature again allows the user application to acknowledged the attribute write operations instead of
            the Bluetooth Low Energy stack doing it automatically.
            </para>
            <para>
            The command should be used when a Value event is received where the reason why value has changed
            corresponds to attributes_attribute_change_reason_write_request_user.
            </para>
            <para>
            This response must be sent within 30 seconds or otherwise a timeout will occur.
            </para>
            </summary>
            <param name="connection">Connection handle to respond to</param>
            <param name="attError">
            <para>Attribute error code to send if an error occurs.</para>
            <para>0x0: Write was accepted</para>
            <para>0x80-0x9F: Reserved for user defined error codes</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.AttributeDatabase.Messenger.SendAsync(System.Byte,System.UInt16,System.Byte[])">
            <summary>
            <para>
            This command will send an attribute value, identified by handle, via a notification or an indication to a remote
            device, but does not modify the current corresponding value in the local GATT database.
            </para>
            <para>
            If this attribute, identified by handle, does not have notification or indication property, or no remote device has
            registered for notifications or indications of this attribute, then an error will be returned.
            </para>
            </summary>
            <param name="connection">
            <para>Connection handle to send to.</para>
            <para>
            Use 0xFF to send to all connected clients which have subscribed to
            receive the notifications or indications.
            </para>
            <para>An error is returned as soon as the first failed transmission occurs.</para>
            </param>
            <param name="handle">Attribute handle to send.</param>
            <param name="value">Data to send.</param>
            <returns></returns>
        </member>
        <member name="E:BGLib.Core.AttributeDatabase.Messenger.Value">
            <summary>
            This event is produced at the GATT server when a local attribute value was written by a remote device.
            </summary>
        </member>
        <member name="E:BGLib.Core.AttributeDatabase.Messenger.UserReadRequest">
            <summary>
            This event is generated when a remote device tries to read an attribute which has the user property enabled.
            This event should be responded within 30 seconds with User Read Response command either containing the
            data or an error code.
            </summary>
        </member>
        <member name="E:BGLib.Core.AttributeDatabase.Messenger.Status">
            <summary>
            This event indicates attribute status flags have changed. For example, this even is generated at the module
            acting as the GATT Server whenever the remote GATT Client changes the Client Characteristic Configuration
            to start or stop notification or indications from the Server.
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeDatabase.StatusEventArgs.Handle">
            <summary>
            Attribute handle
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeDatabase.StatusEventArgs.Flags">
            <summary>
            Attribute status flags
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeDatabase.UserReadRequestEventArgs.Connection">
            <summary>
            Connection ID which requested attribute
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeDatabase.UserReadRequestEventArgs.Handle">
            <summary>
            Attribute handle requested
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeDatabase.UserReadRequestEventArgs.Offset">
            <summary>
            Attribute offset to send data from
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeDatabase.UserReadRequestEventArgs.MaxSize">
            <summary>
            <para>Maximum data size to respond with</para>
            <para>
            If more data is sent than indicated by this parameter, the extra bytes will be
            ignored.
            </para>
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeDatabase.ValueEventArgs.Connection">
            <summary>
            Connection handle
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeDatabase.ValueEventArgs.Reason">
            <summary>
            Reason why value has changed
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeDatabase.ValueEventArgs.Handle">
            <summary>
            Attribute handle, which was changed
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeDatabase.ValueEventArgs.Offset">
            <summary>
            Offset into attribute value where data starts
            </summary>
        </member>
        <member name="P:BGLib.Core.AttributeDatabase.ValueEventArgs.Value">
            <summary>
            Attribute value
            </summary>
        </member>
        <member name="T:BGLib.Core.Connection.ConnectionStatus">
            <summary>
            The possible connection status flags are described in the table below. The flags field is a bit mask, so multiple
            flags can be set at a time.If the bit is 1 the flag is active and if the bit is 0 the flag is inactive.
            </summary>
        </member>
        <member name="F:BGLib.Core.Connection.ConnectionStatus.Connected">
            <summary>
            This status flag tells the connection exists to a remote device.
            </summary>
        </member>
        <member name="F:BGLib.Core.Connection.ConnectionStatus.Encrypted">
            <summary>
            This flag tells the connection is encrypted.
            </summary>
        </member>
        <member name="F:BGLib.Core.Connection.ConnectionStatus.Completed">
            <summary>
            Connection completed flag, which is used to tell a new connection
            has been created.
            </summary>
        </member>
        <member name="F:BGLib.Core.Connection.ConnectionStatus.ParametersChange">
            <summary>
            This flag tells that connection parameters have changed and. It is
            set when connection parameters have changed due to a link layer
            operation.
            </summary>
        </member>
        <member name="P:BGLib.Core.Connection.DisconnectedEventArgs.Connection">
            <summary>
            Connection handle
            </summary>
        </member>
        <member name="P:BGLib.Core.Connection.DisconnectedEventArgs.Reason">
            <summary>
            <para>Disconnection reason code</para>
            <para>0 : disconnected by local user</para>
            </summary>
        </member>
        <member name="P:BGLib.Core.Connection.FeatureIndEventArgs.Connection">
            <summary>
            Connection handle
            </summary>
        </member>
        <member name="P:BGLib.Core.Connection.FeatureIndEventArgs.Features">
            <summary>
            CtrData field from LL_FEATURE_RSP - packet
            </summary>
        </member>
        <member name="T:BGLib.Core.Connection.Messenger">
            <summary>
            The Connection class provides methods to manage Bluetooth connections and query their statuses.
            </summary>
        </member>
        <member name="M:BGLib.Core.Connection.Messenger.DisconnectAsync(System.Byte)">
            <summary>
            <para>This command disconnects an active Bluetooth connection.</para>
            <para>When link is disconnected a Disconnected event is produced.</para>
            </summary>
            <param name="connection">Connection handle to close</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Connection.Messenger.GetRssiAysnc(System.Byte)">
            <summary>
            <para>
            This command returns the Receiver Signal Strength Indication (RSSI) related to the connection referred to by
            the connection handle parameter.If the connection is not open, then the RSSI value returned in the response
            packet will be 0x00, while if the connection is active, then it will be some negative value (2's complement form
            between 0x80 and 0xFF and never 0x00). Note that this command also returns an RSSI of 0x7F if you request
            RSSI on an invalid/unsupported handle.
            </para>
            <para>
            At -38 dBm the BLE112 receiver is saturated. The measurement value may depend on the used
            hardware and design.
            </para>
            </summary>
            <param name="connection">Connection handle</param>
            <returns>
            <para>RSSI value of the connection in dBm.</para>
            <para>Range: -103 to -38</para>
            </returns>
        </member>
        <member name="M:BGLib.Core.Connection.Messenger.UpdateAysnc(System.Byte,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            <para>
            This command updates the connection parameters of a given connection. The parameters have the same
            meaning and follow the same rules as for the GAP class command : Connect Direct.
            </para>
            <para>
            If this command is issued at a master device, it will send parameter update request to the Bluetooth link layer.
            </para>
            <para>
            On the other hand if this command is issued at a slave device, it will send L2CAP connection parameter update
            request to the master, which may either accept or reject it.
            </para>
            <para>
            It will take an amount of time corresponding to at least six times the current connection interval before the new
            connection parameters will become active.
            </para>
            </summary>
            <param name="connection">Connection handle</param>
            <param name="intervalMin">Minimum connection interval (units of 1.25ms)</param>
            <param name="intervalMax">Maximum connection interval (units of 1.25ms)</param>
            <param name="latency">
            Slave latency which defines how many connections intervals a slave may
            skip.
            </param>
            <param name="timeout">Supervision timeout (units of 10ms)</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Connection.Messenger.VersionUpdateAysnc(System.Byte)">
            <summary>
            This command requests a version exchange of a given connection.
            </summary>
            <param name="connection">Connection handle</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Connection.Messenger.ChannelMapGetAysnc(System.Byte)">
            <summary>
            This command can be used to read the current Channel Map.
            </summary>
            <param name="connection">Connection handle</param>
            <returns>
            <para>
            Current Channel Map. Each bit corresponds to one channel. 0-bit
            corresponds to 0 channel.Size of Channel Map is 5 bytes.
            </para>
            <para>Channel range: 0-36</para>
            </returns>
        </member>
        <member name="M:BGLib.Core.Connection.Messenger.ChannelMapSetAysnc(System.Byte,System.Byte[])">
            <summary>
            This command can be used to set the new Channel Map.
            </summary>
            <param name="connection">Connection handle</param>
            <param name="map">
            <para>
            New Channel Map. Channel Map is 5 bytes array. Each bit corresponds to
            one channel. 0-bit corresponds to 0 channel.
            </para>
            <para>Channel range: 0-36</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Connection.Messenger.GetStatusAysnc(System.Byte)">
            <summary>
            <para>This command returns the status of the given connection.</para>
            <para>Status is returned in a Status event.</para>
            </summary>
            <param name="connection">Connection handle</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Connection.Messenger.SlaveLatencyDisableAysnc(System.Byte)">
            <summary>
            This command temporarily enables or disables slave latency.
            </summary>
            <param name="disable">
            <para>0: enables slave latency</para>
            <para>1: disables slave latency</para>
            </param>
            <returns></returns>
        </member>
        <member name="E:BGLib.Core.Connection.Messenger.Status">
            <summary>
            This event indicates the connection status and parameters.
            </summary>
        </member>
        <member name="E:BGLib.Core.Connection.Messenger.VersionInd">
            <summary>
            This event indicates the remote devices version.
            </summary>
        </member>
        <member name="E:BGLib.Core.Connection.Messenger.FeatureInd">
            <summary>
            This event indicates the remote devices features.
            </summary>
        </member>
        <member name="E:BGLib.Core.Connection.Messenger.Disconnected">
            <summary>
            This event is produced when a Bluetooth connection is disconnected.
            </summary>
        </member>
        <member name="P:BGLib.Core.Connection.StatusEventArgs.Connection">
            <summary>
            Connection handle
            </summary>
        </member>
        <member name="P:BGLib.Core.Connection.StatusEventArgs.Flags">
            <summary>
            Connection status flags use connstatus-enumerator
            </summary>
        </member>
        <member name="P:BGLib.Core.Connection.StatusEventArgs.Address">
            <summary>
            Remote devices Bluetooth address
            </summary>
        </member>
        <member name="P:BGLib.Core.Connection.StatusEventArgs.AddressType">
            <summary>
            Remote address type see: Bluetooth Address Types--gap
            </summary>
        </member>
        <member name="P:BGLib.Core.Connection.StatusEventArgs.ConnInterval">
            <summary>
            Current connection interval (units of 1.25ms)
            </summary>
        </member>
        <member name="P:BGLib.Core.Connection.StatusEventArgs.Timeout">
            <summary>
            Current supervision timeout (units of 10ms)
            </summary>
        </member>
        <member name="P:BGLib.Core.Connection.StatusEventArgs.Latency">
            <summary>
            Slave latency which tells how many connection intervals the slave may
            skip.
            </summary>
        </member>
        <member name="P:BGLib.Core.Connection.StatusEventArgs.Bonding">
            <summary>
            <para>Bonding handle if the device has been bonded with.</para>
            <para>Otherwise: 0xFF</para>
            </summary>
        </member>
        <member name="P:BGLib.Core.Connection.VersionIndEventArgs.Connection">
            <summary>
            Connection handle
            </summary>
        </member>
        <member name="P:BGLib.Core.Connection.VersionIndEventArgs.VersNr">
            <summary>
            Bluetooth controller specification version
            </summary>
        </member>
        <member name="P:BGLib.Core.Connection.VersionIndEventArgs.CompId">
            <summary>
            Manufacturer of the Bluetooth controller
            </summary>
        </member>
        <member name="P:BGLib.Core.Connection.VersionIndEventArgs.SubVersNr">
            <summary>
            Bluetooth controller version
            </summary>
        </member>
        <member name="T:BGLib.Core.DFU.Messenger">
            <summary>
            <para>
            The commands and events in the DFU (Device firmware upgrade) can be used to perform a firmware upgrade
            to the local device for example over the UART interface.
            </para>
            <para>
            The commands in this class are only available when the module has been booted into DFU mode with the reset
            command.
            </para>
            <para>
            It is not possible to use other commands in DFU mode, bootloader can't parse commands not related with DFU.
            </para>
            </summary>
        </member>
        <member name="M:BGLib.Core.DFU.Messenger.Reset(System.Byte)">
            <summary>
            <para>
            This command resets the Bluetooth module or the dongle. This command does not have a response, but the
            consequent following event will be the normal boot event (system_boot) or the DFU boot event (dfu_boot) if
            the DFU option is used and UART boot loader is installed.
            </para>
            <para>
            There are three available boot loaders: USB for DFU upgrades using the USB-DFU protocol over the USB
            interface, UART for DFU upgrades using the BGAPI protocol over the UART interface, and OTA for the
            Over-the-Air upgrades.
            </para>
            </summary>
            <param name="dfu">
            <para>Whether or not to boot into DFU mode:</para>
            <para>0: Reboot normally</para>
            <para>1: Reboot into DFU mode for communication with the currently installed boot loader
            (UART, USB or OTA)
            </para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.DFU.Messenger.SetAddressAsync(System.UInt32)">
            <summary>
            <para>
            After the device has been boot into DFU mode, and if the UART bootloader is used (defined in project
            configuration file), this command can be used to start the DFU firmware upgrade.
            </para>
            <para>The UART DFU process:</para>
            <para>1. Boot device to DFU mode with : Reset command.</para>
            <para>2. Wait for DFU Boot event</para>
            <para>3. Send command Flash Set Address to start the firmware update.</para>
            <para>4. Upload the firmware with Flash Upload commands until all the data has been uploaded. Use data
            contained in the firmware image.hex file starting from byte offset 0x1000: everything before this offset is
            bootloader data which cannot be written using DFU; also, the last 2kB are skipped because they contain
            the hardware page and other configuration data that cannot be changed over DFU.</para>
            <para>5. Send Flash Upload Finish to when all the data has been uploaded.</para>
            <para>6. Finalize the DFU firmware update with command: Reset.</para>
            </summary>
            <param name="address">
            <para>The offset in the flash where to start flashing.</para>
            <para>Always use: 0x1000</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.DFU.Messenger.UploadAsync(System.Byte[])">
            <summary>
            <para>
            This command is used repeatedly to upload the new binary firmware image to module over the UART interface.
            The address on the flash will be updated automatically.
            </para>
            <para>When all data is uploaded finalize the upload with command: Flash Upload Finish.</para>
            </summary>
            <param name="data">
            <para>An array of data which will be written into the flash.</para>
            <para>
            The amount of data in the array MUST be 1, 2, 4, 8, 16, 32 or 64 bytes or
            otherwise the firmware update will fail.
            </para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.DFU.Messenger.UploadFinishAsync">
            <summary>
            This command tells to the device that the uploading of DFU data has finished. After this command the issue still
            Reset command to restart the Bluetooth module in normal mode.
            </summary>
            <returns></returns>
        </member>
        <member name="E:BGLib.Core.DFU.Messenger.Boot">
            <summary>
            Device has booted up in DFU mode and is ready to receive commands
            </summary>
        </member>
        <member name="T:BGLib.Core.GAP.AddressType">
            <summary>
            Bluetooth address types
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.AddressType.Public">
            <summary>
            Public Address
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.AddressType.Random">
            <summary>
            Random Address
            </summary>
        </member>
        <member name="T:BGLib.Core.GAP.AdFlag">
            <summary>
            Scan header flags
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.AdFlag.LimitedDiscoverable">
            <summary>
            Limited discoverability
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.AdFlag.GeneralDiscoverable">
            <summary>
            General discoverability
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.AdFlag.BredrNotSupported">
            <summary>
            BR/EDR not supported
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.AdFlag.SimultaneousLebredrCtrl">
            <summary>
            BR/EDR controller
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.AdFlag.SimultaneousLebredrHost">
            <summary>
            BE/EDR host
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.AdFlag.Mask">
            <summary>
            -
            </summary>
        </member>
        <member name="T:BGLib.Core.GAP.AdvertisingPolicy">
            <summary>
            Advertising policy
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.AdvertisingPolicy.All">
            <summary>
            Respond to scan requests from any master, allow connection
            from any master (default)
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.AdvertisingPolicy.WhitelistScan">
            <summary>
            Respond to scan requests from whitelist only, allow connection
            from any
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.AdvertisingPolicy.WhitelistConnect">
            <summary>
            Respond to scan requests from any, allow connection from
            whitelist only
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.AdvertisingPolicy.WhitelistAll">
            <summary>
            Respond to scan requests from whitelist only, allow connection
            from whitelist only
            </summary>
        </member>
        <member name="T:BGLib.Core.GAP.ConnectableMode">
            <summary>
            GAP connectable modes
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.ConnectableMode.NonConnectable">
            <summary>
            Not connectable
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.ConnectableMode.DirectedConnectable">
            <summary>
            Directed Connectable
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.ConnectableMode.UndirectedConnectable">
            <summary>
            Undirected connectable
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.ConnectableMode.ScannableNonConnectable">
            <summary>
            Same as non-connectable, but also supports ADV_SCAN_IND
            packets. Device accepts scan requests (active scanning) but is
            not connectable.
            </summary>
        </member>
        <member name="T:BGLib.Core.GAP.DiscoverableMode">
            <summary>
            GAP discoverable modes
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.DiscoverableMode.NoneDiscoverable">
            <summary>
            Non-discoverable mode: the LE Limited Discoverable Mode and the
            LE General Discoverable Mode bits are NOT set in the Flags AD
            type. A master can still connect to the advertising slave in this mode.
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.DiscoverableMode.LimitedDiscoverable">
            <summary>
            Discoverable using limited scanning mode: the advertisement
            packets will carry the LE Limited Discoverable Mode bit set in the
            Flags AD type.
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.DiscoverableMode.GeneralDiscoverable">
            <summary>
            Discoverable using general scanning mode: the advertisement
            packets will carry the LE General Discoverable Mode bit set in the
            Flags AD type.
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.DiscoverableMode.Broadcast">
            <summary>
            Same as <see cref="F:BGLib.Core.GAP.DiscoverableMode.NoneDiscoverable"/> above.
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.DiscoverableMode.UserData">
            <summary>
            In this advertisement the advertisement and scan response data
            defined by user will be used. The user is responsible of building the
            advertisement data so that it also contains the appropriate desired
            Flags AD type.
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.DiscoverableMode.EnhancedBroadcasting">
            <summary>
            When turning the most highest bit on in GAP discoverable mode, the
            remote devices that send scan request packets to the advertiser are
            reported back to the application through Scan Response event.
            This is so called Enhanced Broadcasting mode.
            </summary>
        </member>
        <member name="T:BGLib.Core.GAP.DiscoverMode">
            <summary>
            GAP Discover modes
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.DiscoverMode.Limited">
            <summary>
            Discover only limited discoverable devices, that is, Slaves which have
            the LE Limited Discoverable Mode bit set in the Flags AD type of their
            advertisement packets.
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.DiscoverMode.Generic">
            <summary>
            Discover limited and generic discoverable devices, that is, Slaves which
            have the LE Limited Discoverable Mode or the LE General
            Discoverable Mode bit set in the Flags AD type of their advertisement
            packets.
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.DiscoverMode.Observation">
            <summary>
            Discover all devices regardless of the Flags AD type, so also devices in
            non-discoverable mode will be reported to host.
            </summary>
        </member>
        <member name="T:BGLib.Core.GAP.Messenger">
            <summary>
            The Generic Access Profile (GAP) class provides methods to control the Bluetooth GAP level functionality of
            the local device. The GAP call for example allows remote device discovery, connection establishment and local
            devices connection and discovery modes. The GAP class also allows the control of local devices privacy
            modes.
            </summary>
        </member>
        <member name="M:BGLib.Core.GAP.Messenger.SetPrivacyFlagsAsync(System.Byte,System.Byte)">
            <summary>
            <para>This command sets GAP central/peripheral privacy flags.</para>
            <para>
            By setting for example peripheral_privacy to 1, the Bluetooth stack will automatically generate a resolvable
            random private address for the advertising packets every time the Set Mode command is used to enter
            advertising mode.
            </para>
            <para>
            By setting privacy mode to 2, the Bluetooth stack will generate a resolvable random private address on
            demand.If peripherial_privacy is set to 2 additionally Set Mode is called with the current Discoverable and
            Connectable parameters.Setting up new mode by Set Mode command does not change generated address.
            </para>
            <para>
            By setting privacy mode to 3, the Bluetooth stack will use a non-resolvable random private address (set by Set
            Nonresolvable Address command). For example if peripheral_privacy is set to 3, the Bluetooth stack will get a
            non-resolvable random private address for the advertising packets every time the Set Mode command is used
            to enter advertising mode.
            </para>
            <para>
            It is not recommended to adjust peripheral privacy unless mandatory by the application, because not
            all Bluetooth implementations can decode resolvable private addresses.
            </para>
            </summary>
            <param name="peripheralPrivacy">
            <para>0: disable peripheral privacy</para>
            <para>1: enable peripheral privacy</para>
            <para>2: change peripheral private address on demand</para>
            <para>3: enable peripheral privacy with non-resolvable address</para>
            <para>Any other value will have no effect on flag</para>
            </param>
            <param name="centralPrivacy">
            <para>0: disable central privacy</para>
            <para>1: enable central privacy</para>
            <para>2: change central private address on demand</para>
            <para>3: enable central privacy with non-resolvable address</para>
            <para>Any other value will have no effect on flag</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.GAP.Messenger.SetModeAsync(BGLib.Core.GAP.DiscoverableMode,BGLib.Core.GAP.ConnectableMode)">
            <summary>
            This command configures the current GAP discoverability and connectability modes. It can be used to enable
            advertisements and/or allow connection.The command is also meant to fully stop advertising, when using
            <see cref="F:BGLib.Core.GAP.DiscoverableMode.NoneDiscoverable"/> and <see cref="F:BGLib.Core.GAP.ConnectableMode.NonConnectable"/>.
            </summary>
            <param name="discover"></param>
            <param name="connect"></param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.GAP.Messenger.DiscoverAsync(BGLib.Core.GAP.DiscoverMode)">
            <summary>
            <para>
            This command starts the GAP discovery procedure to scan for advertising devices i.e. to perform a device
            discovery.
            </para>
            Scanning parameters can be configured with the <see cref="!:SetScanParametersAsync(ushort, ushort, bool)"/>
            <para>
            To cancel on an ongoing discovery process use the <see cref="M:BGLib.Core.GAP.Messenger.EndProcedureAsync"/>
            </para>
            </summary>
            <param name="mode">GAP Discover modes</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.GAP.Messenger.ConnectDirectAsync(System.Byte[],BGLib.Core.GAP.AddressType,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            <para>
            This command will start the GAP direct connection establishment procedure to a dedicated Bluetooth Smart
            device.
            </para>
            <para>
            The Bluetooth module will enter a state where it continuously scans for the connectable advertisement packets
            from the remote device which matches the Bluetooth address gives as a parameter.Upon receiving the
            advertisement packet, the module will send a connection request packet to the target device to imitate a
            Bluetooth connection.A successful connection will bi indicated by a Status event.
            </para>
            <para>
            If the device is configured to support more than one connection, the smallest connection interval which is
            divisible by maximum_connections * 2.5ms will be selected. Thus, it is important to provide minimum and
            maximum connection intervals so that such a connection interval is available within the range.
            </para>
            <para>
            The connection establishment procedure can be cancelled with <see cref="M:BGLib.Core.GAP.Messenger.EndProcedureAsync"/>.
            </para>
            </summary>
            <param name="address">Bluetooth address of the target device</param>
            <param name="connIntervalMin">
            <para>Minimum Connection Interval (in units of 1.25ms).</para>
            <para>Range: 6 - 3200</para>
            <para>
            The lowest possible Connection Interval is 7.50ms and the largest is
            4000ms.
            </para>
            </param>
            <param name="connIntervalMax">
            <para>Maximum Connection Interval (in units of 1.25ms).</para>
            <para>Range: 6 - 3200</para>
            <para>
            Must be equal or bigger than minimum Connection Interval.
            </para>
            </param>
            <param name="timeout">
            <para>
            Supervision Timeout (in units of 10ms). The Supervision Timeout
            defines how long the devices can be out of range before the
            connection is closed.
            </para>
            <para>
            Range: 10 - 3200
            </para>
            <para>
            Minimum time for the Supervision Timeout is 100ms and maximum
            value is 32000ms.
            </para>
            <para>
            According to the specification, the Supervision Timeout in
            milliseconds shall be larger than(1 + latency) * conn_interval_max
            * 2, where conn_interval_max is given in milliseconds.
            </para>
            </param>
            <param name="latency">
            <para>
            This parameter configures the slave latency. Slave latency defines
            how many connection intervals a slave device can skip.
            Increasing slave latency will decrease the energy consumption of
            the slave in scenarios where slave does not have data to send at
            every connection interval.
            </para>
            <para>
            Range: 0 - 500
            </para>
            <para>
            0 : Slave latency is disabled.
            </para>
            <para>
            Example:
            </para>
            <para>
            Connection interval is 10ms and slave latency is 9: this means that
            the slave is allowed to communicate every 100ms, but it can
            communicate every 10ms if needed.
            </para>
            </param>
            <returns>Connection handle that is reserved for new connection</returns>
        </member>
        <member name="M:BGLib.Core.GAP.Messenger.EndProcedureAsync">
            <summary>
            This command ends the current GAP discovery procedure and stop the scanning of advertising devices.
            </summary>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.GAP.Messenger.ConnectSelectiveAsync(System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            <para>
            This command will start the GAP direct connection establishment procedure to a set of dedicated Bluetooth
            Low Energy devices.
            </para>
            <para>When this command is issued the the Bluetooth module will enter a state where it scans connectable
            advertisement packets from the remote devices which are registered in the local white list. Upon receiving an
            advertisement packet from one of the registered devices, the module will send a connection request to this
            device, and a successful connection will produce a connection status event.</para>
            <para>The connect selective command can be cancelled with End Procedure command.</para>
            <para>When in Initiating State there are no scan response events.</para>
            </summary>
            <param name="connIntervalMin">
            <para>Minimum connection interval (in units of 1.25ms).</para>
            <para>Range: 6 - 3200</para>
            <para>
            The lowest possible connection interval is 7.50ms and the largest is
            4000ms.
            </para>
            <para>
            When more then one connection is supported the connection interval
            values(minimum and maximum) used in all connection commands
            must be divisible by connection count* 2.5ms
            </para>
            </param>
            <param name="connIntervalMax">
            <para>Maximum connection interval (in units of 1.25ms).</para>
            <para>Range: 6 - 3200</para>
            <para>Must be equal or bigger than minimum connection interval.</para>
            </param>
            <param name="timeout">
            <para>
            Supervision timeout (in units of 10ms). The supervision timeout defines
            how long the devices can be out of range before the connection is
            closed.
            </para>
            <para>Range: 10 - 3200</para>
            <para>
            Minimum time for the supervision timeout is 100ms and maximum
            value: 32000ms.Supervision timeout must also be equal or grater than
            maximum connection interval.
            </para>
            </param>
            <param name="latency">
            <para>
            This parameter configures the slave latency. Slave latency defines
            how many connection intervals a slave device can skip.
            Increasing slave latency will decrease the energy consumption of the
            slave in scenarios where slave does not have data to send at every
            connection interval.
            </para>
            <para>Range: 0 - 500</para>
            <para>0 : Slave latency is disabled.</para>
            <para>Example:</para>
            <para>
            Connection interval is 10ms and slave latency is 9: this means that the
            slave is allowed to communicate every 100ms, but it can communicate
            every 10ms if needed.
            <para>Note:</para>
            <para>
            Slave Latency x Connection interval can NOT be higher than
            supervision timeout.
            </para>
            </para>
            </param>
            <returns>Connection handle reserved for connection</returns>
        </member>
        <member name="M:BGLib.Core.GAP.Messenger.SetFilteringAsync(BGLib.Core.GAP.ScanPolicy,BGLib.Core.GAP.AdvertisingPolicy,System.Byte)">
            <summary>
            This command can be used to set scan, connection, and advertising filtering parameters based on the local
            devices white list.See also Whitelist Append command.
            </summary>
            <param name="scanPolicy"></param>
            <param name="advPolicy"></param>
            <param name="scanDuplicateFiltering">
            <para>0: Do not filter duplicate advertisers</para>
            <para>1: Filter duplicates</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.GAP.Messenger.SetScanParametersAsync(System.UInt16,System.UInt16,System.Byte)">
            <summary>
            <para>
            This command sets the scan parameters which affect how other Bluetooth Smart devices are discovered. See
            BLUETOOTH SPECIFICATION Version 4.0 [Vol 6 - Part B - Chapter 4.4.3].
            </para>
            <para>
            Keep in mind that when scan window value is equal to scan interval value, CPU may not have enough
            time to switch between speed of the system clock when using slow clock option and as a result the
            current consumption may not decrease.
            </para>
            </summary>
            <param name="scanInterval">
            <para>
            Scan interval defines the interval when scanning is re-started in units of
            625us
            </para>
            <para>
            Range: 0x4 - 0x4000
            </para>
            <para>
            Default: 0x4B (46,875ms)
            </para>
            <para>
            After every scan interval the scanner will change the frequency it operates at
            at it will cycle through all the three advertisements channels in a round robin
            fashion.According to the Bluetooth specification all three channels must be
            used by a scanner.
            </para>
            </param>
            <param name="scanWindow">
            <para>
            Scan Window defines how long time the scanner will listen on a certain
            frequency and try to pick up advertisement packets.Scan window is defined
            as units of 625us
            </para>
            <para>
            Range: 0x4 - 0x4000
            </para>
            <para>
            Default: 0x32 (31,25 ms)
            </para>
            <para>
            Scan windows must be equal or smaller than scan interval
            If scan window is equal to the scan interval value, then the Bluetooth module
            will be scanning at a 100% duty cycle.
            If scan window is half of the scan interval value, then the Bluetooth module
            will be scanning at a 50% duty cycle.
            </para>
            </param>
            <param name="active">
            <para>0: Passive scanning is used. No scan request is made.</para>
            <para>
            1: Active scanning is used. When an advertisement packet is received the
            Bluetooth stack will send a scan request packet to the advertiser to try and
            read the scan response data.
            </para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.GAP.Messenger.SetAdvParametersAsync(System.UInt16,System.UInt16,System.Byte)">
            <summary>
            <para>This command is used to set the advertising parameters.</para>
            <para>
            Example: If the minimum advertisement interval is 40ms and the maximum advertisement interval is 100ms
            then the real advertisement interval will be mostly the middle value(70ms) plus a randomly added 20ms delay,
            which needs to be added according to the Bluetooth specification.
            </para>
            <para>
            If you are currently advertising, then any changes set using this command will not take effect until you
            stop and re-start advertising.
            </para>
            </summary>
            <param name="advIntervalMin">
            <para>Minimum advertisement interval in units of 625us</para>
            <para>Range: 0x20 to 0x4000</para>
            <para>Default: 0x200 (320ms)</para>
            <para>Explanation:</para>
            <para>0x200 = 512</para>
            <para>512 * 625us = 320000us = 320ms</para>
            </param>
            <param name="advIntervalMax">
            <para>Maximum advertisement interval in units of 625us.</para>
            <para>Range: 0x20 to 0x4000</para>
            <para>Default: 0x200 (320ms)</para>
            </param>
            <param name="advChannels">
            <para>A bit mask to identify which of the three advertisement channels are used.</para>
            <para>Examples:</para>
            <para>0x07: All three channels are used</para>
            <para>0x03: Advertisement channels 37 and 38 are used.</para>
            <para>0x04: Only advertisement channel 39 is used</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.GAP.Messenger.SetAdvDataAsync(System.Byte,System.Byte[])">
            <summary>
            <para>
            This commands set advertisement or scan response data used in the advertisement and scan response
            packets.The command allows application specific data to be broadcasts either in advertisement or scan
            response packets.
            </para>
            <para>The data set with this command is only used when the GAP discoverable mode is set to gap_user_data.</para>
            <para>
            Notice that advertisement or scan response data must be formatted in accordance to the Bluetooth Core
            Specification.See BLUETOOTH SPECIFICATION Version 4.0 [Vol 3 - Part C - Chapter 11].
            </para>
            </summary>
            <param name="setScanrsp">
            <para>Advertisement data type</para>
            <para>0 : sets advertisement data</para>
            <para>1 : sets scan response data</para>
            </param>
            <param name="advData">Advertisement data to send</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.GAP.Messenger.SetDirectedConnectableModeAsync(System.Byte[],BGLib.Core.GAP.AddressType)">
            <summary>
            <para>This command sets device to Directed Connectable mode.</para>
            <para>
            In this mode the device uses fast advertisement procedure for the first 1.28 seconds, after which the device
            enters a non-connectable mode.If the device implements the Peripheral Preferred Connection Parameters
            characteristic in its GAP service the parameters defined by this characteristic will be used for the connection.
            </para>
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.GAP.Messenger.SetInitiatingConParametersAsync(System.UInt16,System.UInt16)">
            <summary>
            This command sets the scan parameters for Initiating State which affect for establishing BLE connection. See
            BLUETOOTH SPECIFICATION Version 4.0 [Vol 6 - Part B - Chapter 4.4.4].
            </summary>
            <param name="scanInterval">
            <para>Scan interval defines the interval when scanning is re-started in units of 625us</para>
            <para>Range: 0x4 - 0x4000</para>
            <para>Default: 0x32 (31,25ms)</para>
            <para>
            After every scan interval the scanner will change the frequency it operates at
            at it will cycle through all the three advertisements channels in a round robin
            fashion.According to the Bluetooth specification all three channels must be
            used by a scanner.
            </para>
            </param>
            <param name="scanWindow">
            <para>
            Scan Window defines how long time the scanner will listen on a certain
            frequency and try to pick up advertisement packets.Scan window is defined
            as units of 625us
            </para>
            <para>Range: 0x4 - 0x4000</para>
            <para>Default: 0x32 (31,25ms)</para>
            <para>Scan windows must be equal or smaller than scan interval</para>
            <para>
            If scan window is equal to the scan interval value, then the Bluetooth module
            will be scanning at a 100% duty cycle.
            </para>
            <para>
            If scan window is half of the scan interval value, then the Bluetooth module
            will be scanning at a 50% duty cycle.
            </para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.GAP.Messenger.SetNonresolvableAddressAsync(System.Byte[])">
            <summary>
            This command set the local device's random Non-Resolvable Bluetooth address. Default local device's random
            Non-Resolvable Bluetooth address is 00:00:00:00:00:01.
            </summary>
            <param name="address">Bluetooth non-resolvable address of the local device</param>
            <returns></returns>
        </member>
        <member name="E:BGLib.Core.GAP.Messenger.ScanResponse">
            <summary>
            This is a scan response event. This event is normally received by a Master which is scanning for advertisement
            and scan response packets from Slaves.
            </summary>
        </member>
        <member name="T:BGLib.Core.GAP.ScanHeader">
            <summary>
            Scan header flags
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.ScanHeader.AdvInd">
            <summary>
            Connectable undirected advertising event
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.ScanHeader.AdvDirectInd">
            <summary>
            Connectable directed advertising event
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.ScanHeader.AdvNonconnInd">
            <summary>
            Non-connectable undirected advertising event
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.ScanHeader.ScanReq">
            <summary>
            Scanner wants information from Advertiser
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.ScanHeader.ScanRsp">
            <summary>
            Advertiser gives more information to Scanner
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.ScanHeader.ConnectReq">
            <summary>
            Initiator wants to connect to Advertiser
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.ScanHeader.AdvDiscoverInd">
            <summary>
            Non-connectable undirected advertising event
            </summary>
        </member>
        <member name="T:BGLib.Core.GAP.ScanPolicy">
            <summary>
            Scan Policy
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.ScanPolicy.All">
            <summary>
            Accept All advertisement Packets (default)
            </summary>
        </member>
        <member name="F:BGLib.Core.GAP.ScanPolicy.Whitelist">
            <summary>
            Ignore advertisement packets from remote slaves not in the running
            whitelist
            </summary>
        </member>
        <member name="P:BGLib.Core.GAP.ScanResponseEventArgs.RSSI">
            <summary>
            <para>RSSI value (dBm)</para>
            <para>Range: -103 to -38</para>
            </summary>
        </member>
        <member name="P:BGLib.Core.GAP.ScanResponseEventArgs.PacketType">
            <summary>
            <para>Scan response header</para>
            <para>0: Connectable Advertisement packet</para>
            <para>2: Non Connectable Advertisement packet</para>
            <para>4: Scan response packet</para>
            <para>6: Discoverable advertisement packet</para>
            </summary>
        </member>
        <member name="P:BGLib.Core.GAP.ScanResponseEventArgs.Sender">
            <summary>
            Advertisers Bluetooth address
            </summary>
        </member>
        <member name="P:BGLib.Core.GAP.ScanResponseEventArgs.AddressType">
            <summary>
            Advertiser address type
            </summary>
        </member>
        <member name="P:BGLib.Core.GAP.ScanResponseEventArgs.Bond">
            <summary>
            Bond handle if there is known bond for this device, 0xff otherwise
            </summary>
        </member>
        <member name="P:BGLib.Core.GAP.ScanResponseEventArgs.Data">
            <summary>
            Scan response data
            </summary>
        </member>
        <member name="P:BGLib.Core.Hardware.AdcResultEventArgs.Input">
            <summary>
            <para>A/D input from which value is received from</para>
            <para>0x0: AIN0 (pin 0 of port P0, denoted as A0 in the ADC row of datasheet's table 3)</para>
            <para>0x1: AIN1</para>
            <para>0x2: AIN2</para>
            <para>0x3: AIN3</para>
            <para>0x4: AIN4</para>
            <para>0x5: AIN5</para>
            <para>0x6: AIN6</para>
            <para>0x7: AIN7</para>
            <para>0x8: AIN0--AIN1 differential</para>
            <para>0x9: AIN2--AIN3 differential</para>
            <para>0xA: AIN4--AIN5 differentia</para>
            <para>0xB: AIN6--AIN7 differential</para>
            <para>0xC: GND</para>
            <para>0xD: Reserved</para>
            <para>0xE: Temperature sensor</para>
            <para>0xF: VDD/3</para>
            </summary>
        </member>
        <member name="P:BGLib.Core.Hardware.AdcResultEventArgs.Value">
            <summary>
            <para>A/D value.</para>
            <para>
            In the example case of 12 effective bits decimation, you will need to read the left-
            most 12 bits of the value to interpret it. It is a 12-bit 2's complement value left-
            aligned to the MSB of the 16-bit container, which means that negative values (which
            are uncommon but not impossible) are 0x8000 or higher, and positive values are
            0x7FF0 or lower.Since it is only 12 bits, the last nibble will always be 0 (0xnnn0).
            You can divide the value by 16 (that is, bit-shift 4 bits to the right) to obtain the
            expected 12-bit value.
            </para>
            </summary>
        </member>
        <member name="P:BGLib.Core.Hardware.AnalogComparatorStatusEventArgs.Timestamp">
            <summary>
            <para>Value of internal timer</para>
            <para>Range: 0 to 2^24-1</para>
            </summary>
        </member>
        <member name="P:BGLib.Core.Hardware.AnalogComparatorStatusEventArgs.Output">
            <summary>
            <para>Analog comparator output</para>
            <para>1: if V+ > V-</para>
            <para>0: if V+ &lt; V-</para>
            </summary>
        </member>
        <member name="P:BGLib.Core.Hardware.IOPortStatusEventArgs.Timestamp">
            <summary>
            <para>Value of internal timer</para>
            <para>Range : 0 to 2^24-1</para>
            </summary>
        </member>
        <member name="P:BGLib.Core.Hardware.IOPortStatusEventArgs.Port">
            <summary>
            I/O port
            </summary>
        </member>
        <member name="P:BGLib.Core.Hardware.IOPortStatusEventArgs.Irq">
            <summary>
            <para>I/O flags</para>
            <para>Tells which port caused interrupt(bitmask).</para>
            </summary>
        </member>
        <member name="P:BGLib.Core.Hardware.IOPortStatusEventArgs.State">
            <summary>
            Current status of all I/Os in port(bitmask).
            </summary>
        </member>
        <member name="T:BGLib.Core.Hardware.Messenger">
            <summary>
            The Hardware class provides methods to access the local devices hardware interfaces such as : A/D
            converters, IO and timers, I2C interface etc.
            </summary>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.IOPortConfigIrqAsync(System.Byte,System.Byte,System.Byte)">
            <summary>
            <para>This command configures the locals I/O-port interrupts.</para>
            <para>
            Interrupts on I/O-port 2 can be enabled only for BLE113 and BLE121LR chip. In this case P2_0 and
            P2_1 pins are available.
            </para>
            </summary>
            <param name="port">
            <para>I/O port selection</para>
            <para>Values: 0 - 2</para>
            </param>
            <param name="enableBits">
            <para>A bit mask which tells which I/O generate an interrupt</para>
            <para>bit 0: Interrupt is enabled</para>
            <para>bit 1: Interrupt is disabled</para>
            </param>
            <param name="fallingEdge">
            <para>Interrupt sense for port.</para>
            <para>0 : rising edge</para>
            <para>1 : falling edge</para>
            <para>Note: affects all IRQ enabled pins on the port</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.SetSoftTimerAsync(System.UInt32,System.Byte,System.Byte)">
            <summary>
            This command configures the local software timer. The timer is 22 bits so the maximum value with BLE112 is
            2^22 = 4194304/32768Hz = 128 seconds.With BLED112 USB dongle the maximum value is 2^22 = 4194304
            /32000Hz = 131 seconds.
            </summary>
            <param name="time">
            <para>Timer interrupt period in units of local crystal frequency.</para>
            <para>time : 1/32768 seconds for modules where the external sleep oscillator must be enabled.</para>
            <para>time : 1/32000 seconds for the dongle where internal RC oscillator is used. If time is 0, scheduled timer is removed.</para>
            </param>
            <param name="handle">Handle that is sent back within triggered event at timeout</param>
            <param name="singleShot">
            <para>Timer mode.</para>
            <para>
            0: Repeating timeout: the timer event is triggered at intervals defined with time
            . The stack only supports one repeating timer at a time for reliability purposes.
            Starting a repeating soft timer removes the current one if any.
            </para>
            <para>
            1: Single timeout: the timer event is triggered only once after a period defined
            with time.There can be up to 8 non-repeating software timers running at the
            same time (max number actually depends on the current activities of the stack,
            so it might be lower than 8 at times.)
            </para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.AdcReadAsync(System.Byte,System.Byte,System.Byte)">
            <summary>
            This command reads the devices local A/D converter. Only a single channel may be read at a time, and each
            conversion must complete before another one is requested.The completion of each conversion is indicated by
            the hardware_adc_result event.
            </summary>
            <param name="input">
            <para>Selects the ADC input.</para>
            <para>0x0: AIN0 (pin 0 of port P0, denoted as A0 in the ADC row of datasheet's table 3)</para>
            <para>0x1: AIN1</para>
            <para>0x2: AIN2</para>
            <para>0x3: AIN3</para>
            <para>0x4: AIN4</para>
            <para>0x5: AIN5</para>
            <para>0x6: AIN6</para>
            <para>0x7: AIN7</para>
            <para>0x8: AIN0--AIN1 differential</para>
            <para>0x9: AIN2--AIN3 differential</para>
            <para>0xA: AIN4--AIN5 differential</para>
            <para>0xB: AIN6--AIN7 differential</para>
            <para>0xC: GND</para>
            <para>0xD: Reserved</para>
            <para>0xE: Temperature sensor</para>
            <para>0xF: VDD/3</para>
            </param>
            <param name="decimation">
            <para>Select resolution and conversion rate for conversion, result is always stored in MSB bits.</para>
            <para>0: 7 effective bits</para>
            <para>1: 9 effective bits</para>
            <para>2: 10 effective bits</para>
            <para>3: 12 effective bits</para>
            </param>
            <param name="referenceSelection">
            <para>Selects the reference for the ADC. Reference corresponds to the maximum allowed input value.</para>
            <para>0: Internal reference (1.24V)</para>
            <para>1: External reference on AIN7 pin</para>
            <para>2: AVDD pin</para>
            <para>3: External reference on AIN6--AIN7 differential input</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.IOPortConfigDirectionAsync(System.Byte,System.Byte)">
            <summary>
            The command configiures I/O-port directions
            </summary>
            <param name="port">I/0 PORT index: 0, 1 or 2</param>
            <param name="direction">
            <para>Bitmask for each individual pin direction</para>
            <para>bit0 means input (default)</para>
            <para>bit1 means output</para>
            <para>Example:</para>
            <para>To configure all port's pins as output use 0xff</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.IOPortConfigFunctionAsync(System.Byte,System.Byte)">
            <summary>
            <para>This command configures the I/O-ports function.</para>
            <para>
            If bit is set in function parameter then the corresponding I/O port is set to peripheral function, otherwise it is
            general purpose I/O pin.
            </para>
            </summary>
            <param name="port">I/O port: 0,1 or 2</param>
            <param name="function">peripheral selection bit for pins</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.IOPortConfigPullAsync(System.Byte,System.Byte,System.Byte)">
            <summary>
            <para>Configure I/O-port pull-up/pull-down</para>
            <para>Pins P1_0 and P1_1 do not have pull-up/pull-down.</para>
            </summary>
            <param name="port">I/O port select: 0, 1 or 2</param>
            <param name="tristateMask">If this bit is set, disabled pull on pin</param>
            <param name="pullUp">
            <para>0: pull all port's pins down</para>
            <para>1: pull all port's pins up</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.IOPortWriteAsync(System.Byte,System.Byte,System.Byte)">
            <summary>
            Write I/O-port statuses
            </summary>
            <param name="port">
            <para>I/O port to write to</para>
            <para>Values: 0,1 or 2</para>
            </param>
            <param name="mask">
            <para>Bit mask to tell which I/O pins to write</para>
            <para>Example:</para>
            <para>To write the status of all IO pins use 0xFF</para>
            </param>
            <param name="data">
            <para>Bit mask to tell which state to write</para>
            <para>bit0: I/O is disabled</para>
            <para>bit1: I/O is enabled</para>
            <para>Example:</para>
            <para>To enable all IO pins use 0xFF</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.IOPortReadAsync(System.Byte,System.Byte)">
            <summary>
            Read I/O-port
            </summary>
            <param name="port">
            <para>I/O port to read</para>
            <para>Values: 0,1 or 2</para>
            </param>
            <param name="mask">
            <para>Bit mask to tell which I/O pins to read</para>
            <para>Example:</para>
            <para>To read the status of all IO pins use 0xFF</para>
            </param>
            <returns>I/O port pin state</returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.SpiConfigAsync(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            The command configures the SPI interface
            </summary>
            <param name="channel">
            <para>USART channel</para>
            <para>Values: 0 or 1</para>
            </param>
            <param name="polarity">
            <para>Clock polarity</para>
            <para>Values: 0 or 1</para>
            </param>
            <param name="phase">
            <para>Clock phase</para>
            <para>Values: 0 or 1</para>
            </param>
            <param name="bitOrder">
            <para>Endianness</para>
            <para>0: LSB</para>
            <para>1: MSB</para>
            </param>
            <param name="baudE">baud rate exponent value</param>
            <param name="baudM">baud rate mantissa value</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.SpiTransferAsync(System.Byte,System.Byte[])">
            <summary>
            <para>
            This command is used to transfer SPI data when in master mode. Maximum of 64 bytes can be transferred at a
            time.
            </para>
            <para>
            Slave select pin is not controlled automatically when transferring data while in SPI master mode, so it
            must be controlled by the application using normal GPIO control commands like IO Port Write
            command.
            </para>
            </summary>
            <param name="channel">
            <para>SPI channel</para>
            <para>Value: 0 or 1</para>
            </param>
            <param name="data">
            <para>Data to transmit</para>
            <para>Maximum length is 64 bytes</para>
            </param>
            <returns>data received from SPI</returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.I2cReadAsync(System.Byte,System.Byte,System.Byte)">
            <summary>
            <para>The command reads data from I2C bus.</para>
            <para>
            BLE112 module: uses bit-bang method and only master-mode is supported in current firmwares, I2C CLK is
            fixed to P1_7 and I2C DATA to P1_6(pull - up must be enabled on both pins), the clock rate is approximately 20 -
            25 kHz and it does vary slightly because other functionality has higher interrupt priority, such as the BLE radio.
            </para>
            <para>
            BLE113/BLE121LR modules: only master-mode is supported in current firmwares, I2C pins are 14/24 (I2C CLK)
            and 15/25 (I2C DATA) as seen in the datasheet, operates at 267kHz.
            </para>
            <para>
            To convert a 7-bit I2C address to an 8-bit one, shift left by one bit. For example, a 7-bit address of
            0x40 (dec 64) would be used as 0x80 (dec 128).
            </para>
            <para>
            I2C commands got a timeout of about 250 ms. If the read operation is timeouted then the
            corresponding command result is returned.
            </para>
            </summary>
            <param name="address">
            I2C's 8-bit slave address according to the note above. Keep read/write bit (LSB) set
            to zero, as the firmware will set it automatically.
            </param>
            <param name="stop">If nonzero Send I2C stop condition after transmission</param>
            <param name="length">Number of bytes to read</param>
            <returns>Data read</returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.I2cWriteAsync(System.Byte,System.Byte,System.Byte[])">
            <summary>
            <para>Write data to I2C bus.</para>
            <para>
            BLE112: uses bit-bang method, only master-mode is supported in current firmwares, I2C CLK is fixed to P1_7
            and I2C DATA to P1_6(pull-up must be enabled on both pins), the clock rate is approximately 20-25 kHz and it
            does vary slightly because other functionality has higher interrupt priority, such as the BLE radio.
            </para>
            <para>
            BLE113/BLE121LR: only master-mode is supported in current firmwares, I2C pins are 14/24 (I2C CLK) and 15
            /25 (I2C DATA) as seen in the datasheet, operates at 267kHz.
            </para>
            <para>
            To convert a 7-bit address to an 8-bit one, shift left by one bit. For example, a 7-bit address of 0x40
            (dec 64) would be used as 0x80 (dec 128).
            </para>
            <para>
            I2C commands got a timeout of about 250 ms. If the write operation is timeouted then the written bytes
            value is 0.
            </para>
            </summary>
            <param name="address">
            I2C's 8-bit slave address according to the note above. Keep read/write bit
            (LSB) set to zero, as the firmware will set it automatically.
            </param>
            <param name="stop">If nonzero Send I2C stop condition after transmission</param>
            <param name="data">Data to write</param>
            <returns>Bytes written</returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.SetTXPowerAsync(System.Byte)">
            <summary>
            Re-configure TX output power.
            </summary>
            <param name="power">
            <para>TX output power level to use</para>
            <para>Range:</para>
            <para>0 to 15 with the BLE112 and the BLED112</para>
            <para>0 to 14 with the BLE113</para>
            <para>0 to 9 with the BLE121LR</para>
            <para>For more information, refer to the &lt;txpower&gt; tag in the hardware.xml configuration file.</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.TimerComparatorAsync(System.Byte,System.Byte,System.Byte,System.UInt16)">
            <summary>
            <para>Set comparator for timer channel.</para>
            <para>
            This command may be used to generate e.g. PWM signals with hardware timer. More information on different
            comparator modes and their usage may be found from Texas Instruments CC2540 User's Guide (SWRU191B),
            section 9.8 Output Compare Mode.
            </para>
            </summary>
            <param name="timer">Timer</param>
            <param name="channel">Timer channel</param>
            <param name="mode">Comparator mode</param>
            <param name="comparatorValue">Comparator value</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.IOPortIrqEnableAsync(System.Byte,System.Byte)">
            <summary>
            <para>
            Enable I/O-port interrupts. When enabled, I/O-port interrupts are triggered on either rising or falling edge. The
            direction when the interrupt occurs may be configured with IO Port Irq Direction command.
            </para>
            <para>
            Interrupts on I/O-port 2 can be enabled only for BLE113 and BLE121LR chip. In this case P2_0 and
            P2_1 pins are available.
            </para>
            </summary>
            <param name="port">
            <para>I/O Port</para>
            <para>Value: 0 - 2</para>
            </param>
            <param name="enableBits">
            <para>Interrupt enable mask for pins</para>
            <para>bit0 means interrupt is disabled</para>
            <para>bit1 means interrupt is enabled</para>
            <para>Example:</para>
            <para>To enable interrupts an all pins use 0xFF</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.IOPortIrqDirectionAsync(System.Byte,System.Byte)">
            <summary>
            <para>Set I/O-port interrupt direction. The direction applies for every pin in the given I/O-port.</para>
            <para>
            Interrupts on I/O-port 2 can be enabled only for BLE113 and BLE121LR chip. In this case P2_0 and
            P2_1 pins are available.
            </para>
            </summary>
            <param name="port">
            <para>I/O Port</para>
            <para>Values: 0 - 2</para>
            </param>
            <param name="fallingEdge">
            <para>Interrupt edge direction for port</para>
            <para>0: rising edge</para>
            <para>1: falling edge</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.AnalogComparatorEnableAsync(System.Byte)">
            <summary>
            Enables or disables the analog comparator. Analog comparator has to be enabled prior using any other analog
            comparator commands.
            </summary>
            <param name="enable">
            <para>0: disable</para>
            <para>1: enable</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.AnalogComparatorReadAsync">
            <summary>
            The command reads analog comparator output. Before using this command, analog comparator has to be
            enabled with <see cref="!:ControlAnalogComparatorAsync(bool)"/> command.
            </summary>
            <returns>
            <para>Analog comparator output</para>
            <para>1: V+ > V-</para>
            <para>0: V+ &lt; V-</para>
            </returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.AnalogComparatorConfigIrqAsync(System.Byte)">
            <summary>
            <para>
            This command configures analog comparator interrupts. Before enabling this interrupt, analog comparator has
            to be first enabled with Analog Comparator Enable command.
            </para>
            <para>
            Analog comparator interrupts are generated by default on rising edge, i.e. when condition V+ > V- becomes
            true. It is also possible to configure the opposite functionality, i.e.interrupts are generated on falling edge when
            V+ &lt; V- becomes true. The interrupt direction may be configured with Io Port Irq Direction command, by setting I
            /O-port 0 direction.Please note that this configuration affects both analog comparator interrupt direction and all I
            /O-port 0 pin interrupt directions.
            </para>
            <para>
            Analog comparator interrupts are automatically disabled once triggered , so that a high frequency signal doesn't
            cause unintended consequences.Continuous operation may be achieved by re-enabling the interrupt as soon
            as the Analog Comparator Status event has been received.
            </para>
            </summary>
            <param name="enabled">
            <para>0: disable interrupts</para>
            <para>1: enable interrupts</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.SetRXGainAsync(System.Byte)">
            <summary>
            This command sets the radio receiver (RX) sensitivity to either high (default) or standard. The exact sensitivity
            value is dependent on the used hardware(refer to the appropriate data sheet).
            </summary>
            <param name="gain">
            <para>0: standard gain</para>
            <para>1: high gain (default)</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.UsbEnableAsync(System.Byte)">
            <summary>
            This command activates (enable) or deactivates USB controller on the BLE112 Bluetooth Low Energy module.
            The USB controller is activated by default when USB is set on in the hardware configuration.On the other
            hand, the USB controller cannot be activated if the USB is not set on in the hardware configuration.
            </summary>
            <param name="enable">
            <para>0: disable USB</para>
            <para>1: enable USB</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.SleepEnableAsync(System.Byte)">
            <summary>
            This command enables or disables sleep mode.
            </summary>
            <param name="enable">
            <para>0: disables sleep mode</para>
            <para>1: enables sleep mode</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Hardware.Messenger.GetTimestampAsync">
            <summary>
            <para>This command returns value of hardware Sleep Timer count.</para>
            <para>
            It can be used (e. g.) for the estimation of statement execution time, as a timestamp, or in code termination after
            a timeout.Value of timestamp isn't incremented when the module is in PM3 power mode.
            </para>
            </summary>
            <returns>Sleep Timer count value</returns>
        </member>
        <member name="E:BGLib.Core.Hardware.Messenger.IOPortStatus">
            <summary>
            <para>This event is produced when I/O port status changes.</para>
            <para>
            The timestamp is only valid if the module doesn't go to PM3 because in that mode the low frequency
            oscillator is turned off.Example of such situation is the module in master mode, but not connected to
            any slave. If module wakes up from an IO interrupt, then the timestamp in the event will not be
            accurate.
            </para>
            <para>
            Setting up the timer by the Set Soft Timer command prevents the module from going to PM3 and
            makes timestamps be valid all the time.
            </para>
            </summary>
        </member>
        <member name="E:BGLib.Core.Hardware.Messenger.SoftTimer">
            <summary>
            This event is produced when software timer interrupt is generated.
            </summary>
        </member>
        <member name="E:BGLib.Core.Hardware.Messenger.AdcResult">
            <summary>
            This events is produced when an A/D converter result is received.
            </summary>
        </member>
        <member name="E:BGLib.Core.Hardware.Messenger.AnalogComparatorStatus">
            <summary>
            <para>This event is produced when analog comparator output changes in the configured direction.</para>
            <para>
            The timestamp is only valid if the module doesn't go to PM3 because in that mode the low frequency
            oscillator is turned off.Example of such situation is the module in master mode, but not connected to
            any slave. If module wakes up from an analog comparator interrupt, then the timestamp in the event
            will not be accurate.
            </para>
            <para>
            Setting up the timer by the Set Soft Timer command prevents the module from going to PM3 and
            makes timestamps be valid all the time.
            </para>
            </summary>
        </member>
        <member name="E:BGLib.Core.Hardware.Messenger.RadioError">
            <summary>
            This event is produced when the radio hardware error appears. The radio hardware error is caused by an
            incorrect state of the radio receiver that reports wrong values of length of packets.The FIFO queue of thereceiver is then wrongly read and as a result the device stops responding. After receiving such event the device
            must be restarted in order to recover.
            </summary>
        </member>
        <member name="P:BGLib.Core.Hardware.SoftTimerEventArgs.Handle">
            <summary>
            The software timer handle
            </summary>
        </member>
        <member name="T:BGLib.Core.Message">
            <summary>
            BGAPI packet format
            </summary>
        </member>
        <member name="P:BGLib.Core.Message.Type">
            <summary>
            Message Type (MT)
            </summary>
        </member>
        <member name="P:BGLib.Core.Message.Category">
            <summary>
            Class ID (CID)
            </summary>
        </member>
        <member name="P:BGLib.Core.Message.Id">
            <summary>
            Command ID (CMD)
            </summary>
        </member>
        <member name="P:BGLib.Core.Message.Value">
            <summary>
            Payload (PL)
            </summary>
        </member>
        <member name="P:BGLib.Core.PS.KeyEventArgs.Key">
            <summary>
            <para>Persistent Store key ID</para>
            <para>Values: 0x8000 to 0x807F</para>
            <para>0xFFFF: All keys have been dumped</para>
            </summary>
        </member>
        <member name="P:BGLib.Core.PS.KeyEventArgs.Value">
            <summary>
            Key value
            </summary>
        </member>
        <member name="T:BGLib.Core.PS.Messenger">
            <summary>
            The Persistent Store (PS) class provides methods to read write and dump the local devices parameters (PS
            keys). The persistent store is an abstract data storage on the local devices flash where an application can store
            data for future use.
            </summary>
        </member>
        <member name="M:BGLib.Core.PS.Messenger.DefragAsync">
            <summary>
            This command defragments the Persistent Store.
            </summary>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.PS.Messenger.DumpAsync">
            <summary>
            This command dumps all Persistent Store keys.
            </summary>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.PS.Messenger.EraseAllAsync">
            <summary>
            <para>
            This command erases all Persistent Store keys.
            </para>
            <para>
            The software needs to be restarted after using this command. During the reset the device will generate
            missing encryption keys and update bonding cache.
            </para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.PS.Messenger.SaveAsync(System.UInt16,System.Byte[])">
            <summary>
            This command saves a Persistent Store (PS) key to the local device. The maximum size of a single PS-key is
            32 bytes and a total of 128 keys are available.
            </summary>
            <param name="key">
            <para>Key to save.</para>
            <para>Values: 0x8000 to 0x807F can be used for persistent storage of user data</para>
            </param>
            <param name="value">Value of the key</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.PS.Messenger.LoadAsync(System.UInt16)">
            <summary>
            This command reads a Persistent Store key from the local device.
            </summary>
            <param name="key">
            <para>Key to load</para>
            <para>Values: 0x8000 to 0x807F</para>
            </param>
            <returns>Key's value</returns>
        </member>
        <member name="M:BGLib.Core.PS.Messenger.EraseAsync(System.UInt16)">
            <summary>
            This command erases a Persistent Store key given as parameter.
            </summary>
            <param name="key">
            <para>Key to erase</para>
            <para>Values: 0x8000 to 0x807F</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.PS.Messenger.ErasePageAsync(System.Byte)">
            <summary>
            <para>
            The command erases a flash page which is allocated for user-data. Every page on the flash is 2kB in size
            starting from the first page indexed as 0.
            <para>
            When flash page is erased all bytes inside that page are set to 0xFF.
            </para>
            </para>
            </summary>
            <param name="page">
            <para>Index of memory page to erase</para>
            <para>0: First 2kB flash page</para>
            <para>1: Next 2kB flash page</para>
            <para>etc.</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.PS.Messenger.WriteDataAsync(System.UInt32,System.Byte[])">
            <summary>
            <para>This command can be used to write data to user data area.</para>
            <para>
            Bits on the flash can only be turned from 1 to 0. To turn the bits from 0 to 1 the Erase Page command
            must be used.Notice that the erase page will erase the full 2kB flash page.
            </para>
            <para>
            The amount of flash reserved for the user data needs to be defined in the application configuration file
            (config.xml).
            </para>
            <para>
            The amount of available user flash depends on the hardware version and whether it has 128kbB or
            256kB flash and also how much flash is left after the Bluetooth Low Energy stack, BGScript application
            and the GATT database.The BGBuild xompiler will show the flash consumption in it's output.
            </para>
            </summary>
            <param name="address">
            <para>Offset in the user data space to write in bytes</para>
            <para>0: 1st byte</para>
            </param>
            <param name="data">Data to write</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.PS.Messenger.ReadDataAsync(System.UInt32,System.Byte)">
            <summary>
            This command can be used to read data from user data area.
            </summary>
            <param name="address">
            <para>Offset in the user data space to start reading from in bytes.</para>
            <para>0: 1st byte</para>
            </param>
            <param name="length">Length to read in bytes</param>
            <returns>
            <para>Data read from flash.</para>
            <para>length is set to 0 if read address was invalid</para>
            </returns>
        </member>
        <member name="E:BGLib.Core.PS.Messenger.Key">
            <summary>
            <para>This event is produced during a Persistent Store key dump which in launched with command PS Dump.</para>
            <para>
            The event reporting a PS Key with address of 0xFFFF and empty value is always sent: it is meant to indicate
            that all existing PS Keys have been read.
            </para>
            </summary>
        </member>
        <member name="P:BGLib.Core.SM.BondingFailEventArgs.Handle">
            <summary>
            Connection handle
            </summary>
        </member>
        <member name="T:BGLib.Core.SM.BondingKey">
            <summary>
            Bonding information stored
            </summary>
        </member>
        <member name="F:BGLib.Core.SM.BondingKey.LTK">
            <summary>
            LTK saved in master
            </summary>
        </member>
        <member name="F:BGLib.Core.SM.BondingKey.AddrPublic">
            <summary>
            Public Address
            </summary>
        </member>
        <member name="F:BGLib.Core.SM.BondingKey.AddrStatic">
            <summary>
            Static Address
            </summary>
        </member>
        <member name="F:BGLib.Core.SM.BondingKey.IRK">
            <summary>
            Identity resolving key for resolvable private addresses
            </summary>
        </member>
        <member name="F:BGLib.Core.SM.BondingKey.EdivRAND">
            <summary>
            EDIV+RAND received from slave
            </summary>
        </member>
        <member name="F:BGLib.Core.SM.BondingKey.CSRK">
            <summary>
            Connection signature resolving key
            </summary>
        </member>
        <member name="F:BGLib.Core.SM.BondingKey.Masterid">
            <summary>
            EDIV+RAND sent to master
            </summary>
        </member>
        <member name="P:BGLib.Core.SM.BondStatusEventArgs.Bond">
            <summary>
            Bonding handle
            </summary>
        </member>
        <member name="P:BGLib.Core.SM.BondStatusEventArgs.KeySize">
            <summary>
            Encryption key size used in long-term key
            </summary>
        </member>
        <member name="P:BGLib.Core.SM.BondStatusEventArgs.MITM">
            <summary>
            <para>Was Man-in-the-Middle mode was used in pairing</para>
            <para>0: No MITM used</para>
            <para>1: MITM was used</para>
            </summary>
        </member>
        <member name="P:BGLib.Core.SM.BondStatusEventArgs.Keys">
            <summary>
            Keys stored for bonding
            </summary>
        </member>
        <member name="T:BGLib.Core.SM.IOCapability">
            <summary>
            Security Manager I/O Capabilities
            </summary>
        </member>
        <member name="F:BGLib.Core.SM.IOCapability.DisplayOnly">
            <summary>
            Display Only
            </summary>
        </member>
        <member name="F:BGLib.Core.SM.IOCapability.DisplayYesNo">
            <summary>
            Display with Yes/No-buttons
            </summary>
        </member>
        <member name="F:BGLib.Core.SM.IOCapability.KeyboardOnly">
            <summary>
            Keyboard Only
            </summary>
        </member>
        <member name="F:BGLib.Core.SM.IOCapability.NoInputNoOutput">
            <summary>
            No Input and No Output
            </summary>
        </member>
        <member name="F:BGLib.Core.SM.IOCapability.KeyboardDisplay">
            <summary>
            Display with Keyboard
            </summary>
        </member>
        <member name="T:BGLib.Core.SM.Messenger">
            <summary>
            The Security Manager (SM) class provides access to the Bluetooth low energy Security Manager and methods
            such as : bonding management and modes and encryption control.
            </summary>
        </member>
        <member name="M:BGLib.Core.SM.Messenger.EncryptStartAsync(System.Byte,System.Byte)">
            <summary>
            <para>This command starts the encryption for a given connection.</para>
            <para>
            Since iOS 9.1 update pairing without bonding is not any more supported by iOS. Calling this APIcommand without being in bondable mode, will cause the connection to fail with devices running iOS
            9.1 or newer.
            </para>
            <para>
            Before using this API command with iOS9.1 or newer you must enable bonding mode with command
            Set Bondable Mode and you must also set then bonding parameter in this API command to 1 (Create
            bonding).
            </para>
            </summary>
            <param name="handle">Connection handle</param>
            <param name="bonding">
            <para>Create bonding if devices are not already bonded</para>
            <para>0: Do not create bonding</para>
            <para>1: Creating bonding</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.SM.Messenger.SetBondableModeAsync(System.Byte)">
            <summary>
            Set device to bondable mode
            </summary>
            <param name="bondable">
            <para>Enables or disables bonding mode</para>
            <para>0 : the device is not bondable</para>
            <para>1 : the device is bondable</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.SM.Messenger.DeleteBondingAsync(System.Byte)">
            <summary>
            This command deletes a bonding from the local security database. There can be a maximum of 8 bonded
            devices stored at the same time, and one of them must be deleted if you need bonding with a 9th device.
            </summary>
            <param name="handle">
            <para>Bonding handle of a device.</para>
            <para>This handle can be obtained for example from events like:</para>
            <para>Scan Response</para>
            <para>Status</para>
            <para>If handle is 0xFF, all bondings will be deleted</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.SM.Messenger.SetParametersAsync(System.Byte,System.Byte,BGLib.Core.SM.IOCapability)">
            <summary>
            This command is used to configure the local Security Manager and its features.
            </summary>
            <param name="mitm">
            <para>0: No Man-in-the-middle protection</para>
            <para>1: Man-in-the-middle protection required</para>
            <para>Default: 0</para>
            </param>
            <param name="minKeySize">
            <para>Minimum key size in Bytes</para>
            <para>Range: 7-16</para>
            <para>Default: 7 (56bits)</para>
            </param>
            <param name="ioCapabilities">
            <para>Configures the local devices I/O capabilities.</para>
            <para>See: SMP IO Capabilities for options.</para>
            <para>Default: No Input and No Output</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.SM.Messenger.PasskeyEntryAsync(System.Byte,System.UInt32)">
            <summary>
            This command is used to enter a passkey required for Man-in-the-Middle pairing. It should be sent as a
            response to Passkey Request event.
            </summary>
            <param name="handle">Connection Handle</param>
            <param name="passkey">
            <para>Passkey</para>
            <para>Range: 000000-999999</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.SM.Messenger.GetBondsAsync">
            <summary>
            This command lists all bonded devices. There can be a maximum of 8 bonded devices. The information related
            to the bonded devices is stored in the Flash memory, so it is persistent across resets and power-cycles.
            </summary>
            <returns>Num of currently bonded devices</returns>
        </member>
        <member name="M:BGLib.Core.SM.Messenger.SetOobDataAsync(System.Byte[])">
            <summary>
            <para>This commands sets the Out-of-Band encryption data for a device.</para>
            <para>Device does not allow any other kind of pairing except OoB if the OoB data is set.</para>
            </summary>
            <param name="oob">
            <para>The OoB data to set, which must be 16 or 0 octets long.</para>
            <para>If the data is empty it clears the previous OoB data.</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.SM.Messenger.WhitelistBondsAsync">
            <summary>
            <para>
            This command will add all bonded devices with a known public or static address to the local devices white list.
            Previous entries in the white list will be first cleared.
            </para>
            <para>
            This command can't be used while advertising, scanning or being connected.
            </para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.SM.Messenger.SetPairingDistributionKeysAsync(System.Byte,System.Byte)">
            <summary>
            Change keys distribution fields in pairing request and response. By default all keys are distributed.
            </summary>
            <param name="initiatorKeys">
            <para>Initiator Key Distribution</para>
            <para>bit0: EncKey (LTK)</para>
            <para>bit1: IdKey (IRK)</para>
            <para>bit2: Sign (CSRK)</para>
            <para>bits3-7: Reserved</para>
            <para>Default: 0x07</para>
            </param>
            <param name="responderKeys">
            <para>Responder Key Distribution</para>
            <para>bit0: EncKey (LTK)</para>
            <para>bit1: IdKey (IRK)</para>
            <para>bit2: Sign (CSRK)</para>
            <para>bits3-7: Reserved</para>
            <para>Default: 0x07</para>
            </param>
            <returns></returns>
        </member>
        <member name="E:BGLib.Core.SM.Messenger.BondingFail">
            <summary>
            This event indicates the bonding has failed for a connection.
            </summary>
        </member>
        <member name="E:BGLib.Core.SM.Messenger.PasskeyDisplay">
            <summary>
            This event tells a passkey should be printed to the user for bonding. This passkey must be entered in the
            remote device for bonding to be successful.
            </summary>
        </member>
        <member name="E:BGLib.Core.SM.Messenger.PasskeyRequest">
            <summary>
            <para>
            This event indicates the Security Manager requests the user to enter passkey. The passkey the user needs to
            enter is displayed by the remote device.
            </para>
            <para>Use Passkey Entry command to respond to request</para>
            </summary>
        </member>
        <member name="E:BGLib.Core.SM.Messenger.BondStatus">
            <summary>
            This event outputs bonding status information.
            </summary>
        </member>
        <member name="P:BGLib.Core.SM.PasskeyDisplayEventArgs.Handle">
            <summary>
            Bluetooth connection handle
            </summary>
        </member>
        <member name="P:BGLib.Core.SM.PasskeyDisplayEventArgs.Passkey">
            <summary>
            Passkey range: 000000-999999
            </summary>
        </member>
        <member name="P:BGLib.Core.SM.PasskeyRequestEventArgs.Handle">
            <summary>
            Connection handle
            </summary>
        </member>
        <member name="P:BGLib.Core.System.BootEventArgs.Major">
            <summary>
            Major software version
            </summary>
        </member>
        <member name="P:BGLib.Core.System.BootEventArgs.Minor">
            <summary>
            Minor software version
            </summary>
        </member>
        <member name="P:BGLib.Core.System.BootEventArgs.Patch">
            <summary>
            Patch ID
            </summary>
        </member>
        <member name="P:BGLib.Core.System.BootEventArgs.Build">
            <summary>
            Build version
            </summary>
        </member>
        <member name="P:BGLib.Core.System.BootEventArgs.LLVersion">
            <summary>
            Link layer version
            </summary>
        </member>
        <member name="P:BGLib.Core.System.BootEventArgs.ProtocolVersion">
            <summary>
            BGAPI protocol version
            </summary>
        </member>
        <member name="P:BGLib.Core.System.BootEventArgs.HW">
            <summary>
            Hardware version
            </summary>
        </member>
        <member name="P:BGLib.Core.System.Counters.TXOK">
            <summary>
            Number of transmitted packets
            </summary>
        </member>
        <member name="P:BGLib.Core.System.Counters.TXRetry">
            <summary>
            Number of retransmitted packets
            </summary>
        </member>
        <member name="P:BGLib.Core.System.Counters.RXOK">
            <summary>
            Number of received packets where CRC was OK
            </summary>
        </member>
        <member name="P:BGLib.Core.System.Counters.RXFail">
            <summary>
            Number of received packets with CRC error
            </summary>
        </member>
        <member name="P:BGLib.Core.System.Counters.MBuf">
            <summary>
            Number of available packet buffers
            </summary>
        </member>
        <member name="T:BGLib.Core.System.Endpoint">
            <summary>
            Data Endpoints used in data routing and interface configuration
            </summary>
        </member>
        <member name="F:BGLib.Core.System.Endpoint.API">
            <summary>
            Command Parser
            </summary>
        </member>
        <member name="F:BGLib.Core.System.Endpoint.Test">
            <summary>
            Radio Test
            </summary>
        </member>
        <member name="F:BGLib.Core.System.Endpoint.Script">
            <summary>
            BGScript (not used)
            </summary>
        </member>
        <member name="F:BGLib.Core.System.Endpoint.USB">
            <summary>
            USB Interface
            </summary>
        </member>
        <member name="F:BGLib.Core.System.Endpoint.UART0">
            <summary>
            USART 0
            </summary>
        </member>
        <member name="F:BGLib.Core.System.Endpoint.UART1">
            <summary>
            USART 1
            </summary>
        </member>
        <member name="P:BGLib.Core.System.EndpointWatermarkRXEventArgs.Endpoint">
            <summary>
            Endpoint index where data was received
            </summary>
        </member>
        <member name="P:BGLib.Core.System.EndpointWatermarkRXEventArgs.Data">
            <summary>
            Received data size
            </summary>
        </member>
        <member name="P:BGLib.Core.System.EndpointWatermarkTXEventArgs.Endpoint">
            <summary>
            Endpoint index where data was sent
            </summary>
        </member>
        <member name="P:BGLib.Core.System.EndpointWatermarkTXEventArgs.Data">
            <summary>
            Space available
            </summary>
        </member>
        <member name="P:BGLib.Core.System.Info.Major">
            <summary>
            Major software version
            </summary>
        </member>
        <member name="P:BGLib.Core.System.Info.Minor">
            <summary>
            Minor software version
            </summary>
        </member>
        <member name="P:BGLib.Core.System.Info.Patch">
            <summary>
            Patch ID
            </summary>
        </member>
        <member name="P:BGLib.Core.System.Info.Build">
            <summary>
            Build version
            </summary>
        </member>
        <member name="P:BGLib.Core.System.Info.LLVersion">
            <summary>
            Link layer version
            </summary>
        </member>
        <member name="P:BGLib.Core.System.Info.ProtocolVersion">
            <summary>
            BGAPI protocol version
            </summary>
        </member>
        <member name="P:BGLib.Core.System.Info.HW">
            <summary>
            Hardware version
            </summary>
        </member>
        <member name="T:BGLib.Core.System.Messenger">
            <summary>
            The System class provides access to the local device and contains functions for example to query the local
            Bluetooth address, read firmware version, read radio packet counters etc.
            </summary>
        </member>
        <member name="M:BGLib.Core.System.Messenger.Reset(System.Byte)">
            <summary>
            This command resets the local device immediately. The command does not have a response.
            </summary>
            <param name="bootInDFU">
            <para>Selects the boot mode</para>
            <para>0: boot to main program</para>
            <para>1: boot to DFU</para>
            </param>
        </member>
        <member name="M:BGLib.Core.System.Messenger.HelloAsync">
            <summary>
            This command can be used to test if the local device is functional. Similar to a typical "AT" -> "OK" test.
            </summary>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.System.Messenger.AddressGetAsync">
            <summary>
            This command reads the local device's public Bluetooth address.
            </summary>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.System.Messenger.GetCountersAsync">
            <summary>
            Read packet counters and resets them, also returns available packet buffers.
            </summary>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.System.Messenger.GetConnectionsAsync">
            <summary>
            This command reads the number of supported connections from the local device.
            </summary>
            <returns>Max supported connections</returns>
        </member>
        <member name="M:BGLib.Core.System.Messenger.GetInfoAsync">
            <summary>
            This command reads the local devices software and hardware versions.
            </summary>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.System.Messenger.EndPointTXAsync(BGLib.Core.System.Endpoint,System.Byte[])">
            <summary>
            Send data to endpoint, error is returned if endpoint does not have enough space
            </summary>
            <param name="endpoint">Endpoint index to send data to</param>
            <param name="data">data to send</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.System.Messenger.WhitelistAppendAsync(System.Byte[],BGLib.Core.GAP.AddressType)">
            <summary>
            Add an entry to the running white list. By the white list you can define for example the remote devices which are
            allowed to establish a connection.See also Set Filtering and Connect Selective(if the white list is empty they
            will not be active). Do not use this command while advertising, scanning, or while being connected. The current
            list is discarded upon reset or power-cycle.
            </summary>
            <param name="address">
            <para>
            Bluetooth device address to add to the running white list
            </para>
            <para>
            Maximum of 8 can be stored before you must clear or remove entires
            </para>
            </param>
            <param name="addressType">Bluetooth address type</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.System.Messenger.WhitelistRemoveAsync(System.Byte[],BGLib.Core.GAP.AddressType)">
            <summary>
            <para>
            Remove an entry from the running white list.
            </para>
            <para>
            Do not use this command while advertising or while being connected.
            </para>
            </summary>
            <param name="address">
            <para>
            Bluetooth device address to add to the running white list
            </para>
            <para>
            Maximum of 8 can be stored before you must clear or remove entires
            </para>
            </param>
            <param name="addressType">Bluetooth address type</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.System.Messenger.WhitelistClearAsync">
            <summary>
            <para>
            Delete all entries on the white list at once.
            </para>
            <para>
            Do not use this command while advertising or while being connected.
            </para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.System.Messenger.EndpointRXAsync(BGLib.Core.System.Endpoint,System.Byte)">
            <summary>
            Read data from an endpoint (i.e., data souce, e.g., UART), error is returned if endpoint does not have enough
            data.
            </summary>
            <param name="endpoint">Endpoint index to read data from</param>
            <param name="size">Size of data to read</param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.System.Messenger.EndpointSetWatermarksAsync(BGLib.Core.System.Endpoint,System.Byte,System.Byte)">
            <summary>
            Set watermarks on both input and output sides of an endpoint. This is used to enable and disable the following
            events: Endpoint Watermark Tx and Endpoint Watermark Rx.
            </summary>
            <param name="endpoint">Endpoint index to set watermarks.</param>
            <param name="rx">
            <para>
            Watermark position on receive buffer
            </para>
            <para>
            0xFF : watermark is not modified
            </para>
            <para>
            0x00 : disables watermark
            </para>
            <para>
            1-63 : sets watermark position
            </para>
            </param>
            <param name="tx">
            <para>
            Watermark position on transmit buffer
            </para>
            <para>
            0xFF : watermark is not modified
            </para>
            <para>
            0x00 : disables watermark
            </para>
            <para>
            1-63 : sets watermark position
            </para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.System.Messenger.AesSetKeyAsync(System.Byte[])">
            <summary>
            This command defines the encryption key that will be used with the AES encrypt and decrypt commands.
            </summary>
            <param name="key">
            <para>
            Encryption key.
            </para>
            <para>
            Key size is 16 bytes, will be zero padded if less.
            </para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.System.Messenger.AesEncryptAsync(System.Byte[])">
            <summary>
            <para>
            This command encrypts the given data using the AES algorithm with the predefined with command Aes
            Setkey.
            </para>
            <para>
            This function uses CBC encryption mode.
            </para>
            </summary>
            <param name="data">
            <para>
            Data to be encrypted
            </para>
            <para>
            Maximum size is 16 bytes, will be zero padded if less.
            </para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.System.Messenger.AesDecryptAsync(System.Byte[])">
            <summary>
            <para>
            This command decrypts the given data using the AES algorithm with the predefined key set with command Aes
            Setkey.
            </para>
            <para>
            This function uses CBC encryption mode.
            </para>
            </summary>
            <param name="data">
            <para>
            Data to be decrypted
            </para>
            <para>
            Maximum size is 16 bytes, will be zero padded if less.
            </para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.System.Messenger.UsbEnumerationStatusGetAsync">
            <summary>
            This command reads the enumeration status of USB device.
            </summary>
            <returns>
            <para>0: USB device is not enumerated</para>
            <para>1: USB device is enumerated</para>
            </returns>
        </member>
        <member name="M:BGLib.Core.System.Messenger.GetBootloaderCrcAsync">
            <summary>
            This command returns CRC-16 (polynomial X + X + X + 1) from bootloader. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.System.Messenger.DelayReset(System.Byte,System.UInt16)">
            <summary>
            <para>
            This command disables USB (if USB is enabled in module configuration), waits time delay in blocking mode and
            after that resets Bluetooth module.This command does not have a response, but the following event will be the
            normal boot event (system_boot) or the DFU boot event (dfu_boot) if the DFU option is used and UART
            bootloader is installed.
            </para>
            <para>
            There are three available bootloaders: USB for DFU upgrades using the USB-DFU protocol over the USB
            interface, UART for DFU upgrades using the BGAPI protocol over the UART interface, and OTA for the Overthe-Air upgrades.
            </para>
            </summary>
            <param name="dfu">
            <para>Whether or not to boot into DFU mode.</para>
            <para>0: Reboot normally</para>
            <para>
            1: Reboot into DFU mode for communication with the currently installed
            bootloader(UART, USB or OTA)
            </para>
            </param>
            <param name="delayMs">Delay reset in milliseconds</param>
        </member>
        <member name="E:BGLib.Core.System.Messenger.Boot">
            <summary>
            <para>
            This event is produced when the device boots up and is ready to receive commands
            </para>
            <para>
            This event is not sent over USB interface.
            </para>
            </summary>
        </member>
        <member name="E:BGLib.Core.System.Messenger.EndpointWatermarkRX">
            <summary>
            This event is generated if the receive (incoming) buffer of the endpoint has been filled with a number of bytes
            equal or higher than the value defined by the command Endpoint Set Watermarks. Data from the receive buffer
            can then be read(and consequently cleared) with the command Endpoint Rx.
            </summary>
        </member>
        <member name="E:BGLib.Core.System.Messenger.EndpointWatermarkTX">
            <summary>
            This event is generated when the transmit (outgoing) buffer of the endpoint has free space for a number of
            bytes equal or higher than the value defined by the command Endpoint Set Watermarks.When there is enough
            free space, data can be sent out of the endpoint by the command Endpoint Tx.
            </summary>
        </member>
        <member name="E:BGLib.Core.System.Messenger.ScriptFailure">
            <summary>
            A BGScript failure has been detected and this event is raised.
            </summary>
        </member>
        <member name="E:BGLib.Core.System.Messenger.NoLicenseKey">
            <summary>
            <para>
            This error is produced when no valid license key found form the Bluetooth Low Energy hardware. When
            there is no valid license key the Bluetooth radio will not be operational.
            </para>
            <para>
            A new license key can be requested from the Bluegiga Technical Support.
            </para>
            </summary>
        </member>
        <member name="E:BGLib.Core.System.Messenger.ProtocolError">
            <summary>
            A protocol error was detected in BGAPI command parser. This event is triggered if a BGAPI command from the
            host contains syntax error(s), or if a command is only partially sent.Then the BGAPI parser has a 1 second
            command timeout and if a valid command is not transmitted within this timeout an error is raised and the partial
            or wrong command will be ignored.
            </summary>
        </member>
        <member name="E:BGLib.Core.System.Messenger.UsbEnumerated">
            <summary>
            Event is generated when USB enumeration status has changed. This event can be triggered by plugging
            module to USB host port or by USB device re-enumeration on host machine.
            </summary>
        </member>
        <member name="P:BGLib.Core.System.ScriptFailureEventArgs.Address">
            <summary>
            Address where failure was detected
            </summary>
        </member>
        <member name="P:BGLib.Core.System.UsbEnumeratedEventArgs.State">
            <summary>
            <para>0: device is not enumerated</para>
            <para>1: device is enumerated</para>
            </summary>
        </member>
        <member name="T:BGLib.Core.Testing.Messenger">
            <summary>
            The Testing API provides access to functions which can be used to put the local device into a test mode
            required for Bluetooth conformance testing.
            </summary>
        </member>
        <member name="M:BGLib.Core.Testing.Messenger.PhyTXAsync(System.Byte,System.Byte,System.Byte)">
            <summary>
            <para>
            This command start PHY packet transmission and the radio starts to send one packet at every 625us. If a
            carrier wave is specified as type then the radio just broadcasts continuous carrier wave.
            </para>
            <para>Sleep mode shall be disabled for BLE121LR-m256k module due to hardware limitation.</para>
            </summary>
            <param name="channel">
            <para>RF channel to use</para>
            <para>Values: 0x00 - 0x27</para>
            <para>channel is (Frequency-2402)/2</para>
            <para>Frequency Range 2402 MHz to 2480 MHz</para>
            </param>
            <param name="length">
            <para>Payload data length as octetes</para>
            <para>Values: 0x00 - 0x25</para>
            </param>
            <param name="type">
            <para>Packet Payload data contents</para>
            <para>0: PRBS9 pseudo-random data</para>
            <para>1: 11110000 sequence</para>
            <para>2: 10101010 sequence</para>
            <para>3: broadcast carrier wave</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Testing.Messenger.PhyRXAsync(System.Byte)">
            <summary>
            This commands starts a PHY receive test. Valid packets received can be read by Phy End command.
            </summary>
            <param name="channel">
            <para>Bluetooth channel to use</para>
            <para>Values: 0x00 - 0x27</para>
            <para>Channel is (Frequency-2402)/2</para>
            <para>Frequency Range 2402 MHz to 2480 MHz</para>
            <para>Examples:</para>
            <para>0x00: 2402MHz</para>
            <para>0x13: 2441MHz</para>
            <para>0x27: 2480MHz</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:BGLib.Core.Testing.Messenger.PhyEndAsync">
            <summary>
            <para>This command ends a PHY test and report received packets.</para>
            <para>PHY - testing commands implement Direct test mode from Bluetooth Core Specification, Volume 6, Part F.</para>
            <para>These commands are meant to be used when testing against separate Bluetooth tester.</para>
            </summary>
            <returns>Received packet counter</returns>
        </member>
        <member name="M:BGLib.Core.Testing.Messenger.GetChannelMapAsync">
            <summary>
            This command can be used to read the Channel Quality Map. Channel Quality Map is cleared after the
            response to this command is sent.Measurements are entered into the Channel Quality Map as packets are
            received over the different channels during a normal connection.
            </summary>
            <returns>
            <para>Channel quality map measurements.</para>
            <para>
            The 37 bytes reported by this response, one per each channel, carry the
            information defined via the Channel Mode configuration command.
            </para>
            </returns>
        </member>
        <member name="M:BGLib.Core.Testing.Messenger.ChannelModeAsync(System.Byte)">
            <summary>
            Set channel quality measurement mode. This command defines the kind of information reported by the
            response to the command Get Channel Map.
            </summary>
            <param name="mode">
            <para>0: RSSI of next packet sent on channel after Get Channel Map is issued</para>
            <para>
            When this mode is selected, the command Get Channel Map must be issued while
            a connection exists.Response will be ready when packets have been sent on all
            the 37 channels.Returned value minus an offset of 103 will give the approximate
            RSSI in dBm.
            </para>
            <para>1: Accumulate error counter</para>
            <para>
            When this mode is selected, the command Get Channel Map must be issued while
            a connection exists.After the command is issued the counter will be reset.
            </para>
            <para>2: Fast channel Sweep</para>
            <para>
            When this mode is selected, the command Get Channel Map must be issued while
            no connection exists.Returned value is of the same kind as in mode 0, but refers to
            the measured background noise.
            </para>
            </param>
            <returns></returns>
        </member>
    </members>
</doc>
